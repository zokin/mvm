void glActiveShaderProgram(GLuint pipeline, GLuint program);
GL_INVALID_OPERATION is generated if pipeline is not a name previously returned from a call to glGenProgramPipelines or if such a name has been deleted by a call to glDeleteProgramPipelines. 
GL_INVALID_OPERATION is generated if program refers to a program object that has not been successfully linked. 

void glActiveTexture(GLenum texture);
GL_INVALID_ENUM is generated if texture is not one of GL_TEXTUREi, where i ranges from 0 to (GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1). 

void glAttachShader(GLuint program, GLuint shader);
GL_INVALID_VALUE is generated if either program or shader is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_OPERATION is generated if shader is not a shader object.
GL_INVALID_OPERATION is generated if shader is already attached to program.

void glBeginConditionalRender(GLuint id, GLenum mode);
GL_INVALID_VALUE is generated if id is not the name of an existing query object. 
GL_INVALID_ENUM is generated if mode is not one of the accepted tokens. 
GL_INVALID_OPERATION is generated if glBeginConditionalRender is called while conditional rendering is active, or if glEndConditionalRender is called while conditional rendering is inactive. 
GL_INVALID_OPERATION is generated if id is the name of a query object with a target other than GL_SAMPLES_PASSED or GL_ANY_SAMPLES_PASSED. 
GL_INVALID_OPERATION is generated if id is the name of a query currently in progress. 

void glEndConditionalRender(void);
GL_INVALID_VALUE is generated if id is not the name of an existing query object. 
GL_INVALID_ENUM is generated if mode is not one of the accepted tokens. 
GL_INVALID_OPERATION is generated if glBeginConditionalRender is called while conditional rendering is active, or if glEndConditionalRender is called while conditional rendering is inactive. 
GL_INVALID_OPERATION is generated if id is the name of a query object with a target other than GL_SAMPLES_PASSED or GL_ANY_SAMPLES_PASSED. 
GL_INVALID_OPERATION is generated if id is the name of a query currently in progress. 

void glBeginQuery(GLenum target, GLuint id);
GL_INVALID_ENUM is generated if target is not one of the accepted tokens. 
GL_INVALID_OPERATION is generated if glBeginQuery is executed while a query object of the same target is already active. 
GL_INVALID_OPERATION is generated if glEndQuery is executed when a query object of the same target is not active. 
GL_INVALID_OPERATION is generated if id is 0. 
GL_INVALID_OPERATION is generated if id is the name of an already active query object. 
GL_INVALID_OPERATION is generated if id refers to an existing query object whose type does not does not match target. 

void glEndQuery(GLenum target);
GL_INVALID_ENUM is generated if target is not one of the accepted tokens. 
GL_INVALID_OPERATION is generated if glBeginQuery is executed while a query object of the same target is already active. 
GL_INVALID_OPERATION is generated if glEndQuery is executed when a query object of the same target is not active. 
GL_INVALID_OPERATION is generated if id is 0. 
GL_INVALID_OPERATION is generated if id is the name of an already active query object. 
GL_INVALID_OPERATION is generated if id refers to an existing query object whose type does not does not match target. 

void glBeginQueryIndexed(GLenum target, GLuint index, GLuint id);
GL_INVALID_ENUM is generated if target is not one of the accepted tokens. 
GL_INVALID_VALUE is generated if index is greater than the query target-specific maximum. 
GL_INVALID_OPERATION is generated if glBeginQueryIndexed is executed while a query object of the same target is already active. 
GL_INVALID_OPERATION is generated if glEndQueryIndexed is executed when a query object of the same target is not active. 
GL_INVALID_OPERATION is generated if id is 0. 
GL_INVALID_OPERATION is generated if id is the name of an already active query object. 
GL_INVALID_OPERATION is generated if id refers to an existing query object whose type does not does not match target. 

void glEndQueryIndexed(GLenum target, GLuint index);
GL_INVALID_ENUM is generated if target is not one of the accepted tokens. 
GL_INVALID_VALUE is generated if index is greater than the query target-specific maximum. 
GL_INVALID_OPERATION is generated if glBeginQueryIndexed is executed while a query object of the same target is already active. 
GL_INVALID_OPERATION is generated if glEndQueryIndexed is executed when a query object of the same target is not active. 
GL_INVALID_OPERATION is generated if id is 0. 
GL_INVALID_OPERATION is generated if id is the name of an already active query object. 
GL_INVALID_OPERATION is generated if id refers to an existing query object whose type does not does not match target. 

void glBeginTransformFeedback(GLenum primitiveMode);
GL_INVALID_OPERATION is generated if glBeginTransformFeedback is executed while transform feedback is active. 
GL_INVALID_OPERATION is generated if glEndTransformFeedback is executed while transform feedback is not active. 
GL_INVALID_OPERATION is generated by glDrawArrays if no geometry shader is present, transform feedback is active and mode is not one of the allowed modes. 
GL_INVALID_OPERATION is generated by glDrawArrays if a geometry shader is present, transform feedback is active and the output primitive type of the geometry shader does not match the transform feedback primitiveMode. 
GL_INVALID_OPERATION is generated by glEndTransformFeedback if any binding point used in transform feedback mode does not have a buffer object bound. 
GL_INVALID_OPERATION is generated by glEndTransformFeedback if no binding points would be used, either because no program object is active of because the active program object has specified no varying variables to record. 

void glEndTransformFeedback(void);
GL_INVALID_OPERATION is generated if glBeginTransformFeedback is executed while transform feedback is active. 
GL_INVALID_OPERATION is generated if glEndTransformFeedback is executed while transform feedback is not active. 
GL_INVALID_OPERATION is generated by glDrawArrays if no geometry shader is present, transform feedback is active and mode is not one of the allowed modes. 
GL_INVALID_OPERATION is generated by glDrawArrays if a geometry shader is present, transform feedback is active and the output primitive type of the geometry shader does not match the transform feedback primitiveMode. 
GL_INVALID_OPERATION is generated by glEndTransformFeedback if any binding point used in transform feedback mode does not have a buffer object bound. 
GL_INVALID_OPERATION is generated by glEndTransformFeedback if no binding points would be used, either because no program object is active of because the active program object has specified no varying variables to record. 

void glBindAttribLocation(GLuint program, GLuint index, const GLchar *name);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_OPERATION is generated if name starts with the reserved prefix "gl_".
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.

void glBindBuffer(GLenum target, GLuint buffer);
GL_INVALID_ENUM is generated if target is not one of the allowable values. 
GL_INVALID_VALUE is generated if buffer is not a name previously returned from a call to glGenBuffers. 

void glBindBufferBase(GLenum target, GLuint index, GLuint buffer);
GL_INVALID_ENUM is generated if target is not GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. 
GL_INVALID_VALUE is generated if index is greater than or equal to the number of target-specific indexed binding points. 
GL_INVALID_VALUE is generated if buffer does not have an associated data store, or if the size of that store is zero. 

void glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
GL_INVALID_ENUM is generated if target is not one of GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. 
GL_INVALID_VALUE is generated if index is greater than or equal to the number of target-specific indexed binding points. 
GL_INVALID_VALUE is generated if size is less than or equal to zero, or if offset + size is greater than the value of GL_BUFFER_SIZE. 
Additional errors may be generated if offset violates any target-specific alignmemt restrictions. 

void glBindBufferBase(GLenum target, GLuint first, GLsizei count, const GLuint *buffers);
GL_INVALID_ENUM is generated if target is not GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. 
GL_INVALID_OPERATION is generated if first + count is greater than the number of target-specific indexed binding points. 
GL_INVALID_OPERATION is generated if any value in buffers is not zero or the name of an existing buffer object. 

void glBindBuffersRange(GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLintptr *sizes);
GL_INVALID_ENUM is generated if target is not GL_ATOMIC_COUNTER_BUFFER, GL_TRANSFORM_FEEDBACK_BUFFER, GL_UNIFORM_BUFFER or GL_SHADER_STORAGE_BUFFER. 
GL_INVALID_OPERATION is generated if first + count is greater than the number of target-specific indexed binding points. 
GL_INVALID_OPERATION is generated if any value in buffers is not zero or the name of an existing buffer object. 
GL_INVALID_VALUE is generated by if any value in offsets is less than zero or if any value in sizes is less than zero. 
GL_INVALID_VALUE is generated if any pair of values in offsets and sizes does not respectively satisfy the constraints described for those parameters for the specified target. 

void glBindFragDataLocation(GLuint program, GLuint colorNumber, const char * name);
GL_INVALID_VALUE is generated if colorNumber is greater than or equal to GL_MAX_DRAW_BUFFERS. 
GL_INVALID_OPERATION is generated if name starts with the reserved gl_ prefix. 
GL_INVALID_OPERATION is generated if program is not the name of a program object. 

void glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const char *name);
GL_INVALID_VALUE is generated if colorNumber is greater than or equal to GL_MAX_DRAW_BUFFERS. 
GL_INVALID_VALUE is generated if colorNumber is greater than or equal to GL_MAX_DUAL_SOURCE_DRAW_BUFFERS and index is greater than or equal to one. 
GL_INVALID_VALUE is generated if index is greater than one. 
GL_INVALID_OPERATION is generated if name starts with the reserved gl_ prefix. 
GL_INVALID_OPERATION is generated if program is not the name of a program object. 

void glBindFramebuffer(GLenum target, GLuint framebuffer);
GL_INVALID_ENUM is generated if target is not GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER or GL_FRAMEBUFFER. 
GL_INVALID_OPERATION is generated if framebuffer is not zero or the name of a framebuffer previously returned from a call to glGenFramebuffers. 

void glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
GL_INVALID_VALUE is generated if unit greater than or equal to the value of GL_MAX_IMAGE_UNITS. 
GL_INVALID_VALUE is generated if texture is not the name of an existing texture object. 
GL_INVALID_VALUE is generated if level or layer is less than zero. 
GL_INVALID_ENUM is generated if access or format is not one of the supported tokens. 

void glBindImageTextures(GLuint first, GLsizei count, const GLuint *textures);
GL_INVALID_OPERATION is generated if first + count is greater than the number of image units supported by the implementation. 
GL_INVALID_OPERATION is generated if any value in textures is not zero or the name of an existing texture object. 
GL_INVALID_OPERATION error is generated if the internal format of the level zero texture image of any texture in textures is not supported. 
GL_INVALID_OPERATION error is generated if the width, height, or depth of the level zero texture image of any texture in textures is zero. 

void glBindProgramPipeline(GLuint pipeline);
GL_INVALID_OPERATION is generated if pipeline is not zero or a name previously returned from a call to glGenProgramPipelines or if such a name has been deleted by a call to glDeleteProgramPipelines. 

void glBindRenderbuffer(GLenum target, GLuint renderbuffer);
GL_INVALID_ENUM is generated if target is not GL_RENDERBUFFER. 
GL_INVALID_OPERATION is generated if renderbuffer is not zero or the name of a renderbuffer previously returned from a call to glGenRenderbuffers. 

void glBindSampler(GLuint unit, GLuint sampler);
GL_INVALID_VALUE is generated if unit is greater than or equal to the value of GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS. 
GL_INVALID_OPERATION is generated if sampler is not zero or a name previously returned from a call to glGenSamplers, or if such a name has been deleted by a call to glDeleteSamplers. 

void glBindSamplers(GLuint first, GLsizei count, const GLuint *samplers);
GL_INVALID_OPERATION is generated if first + count is greater than the number of sampler units supported by the implementation. 
GL_INVALID_OPERATION is generated if any value in samplers is not zero or the name of an existing sampler object. 

void glBindTexture(GLenum target, GLuint texture);
GL_INVALID_ENUM is generated if target is not one of the allowable values. 
GL_INVALID_VALUE is generated if target is not a name returned from a previous call to glGenTextures. 
GL_INVALID_OPERATION is generated if texture was previously created with a target that doesn't match that of target. 

void glBindTextures(GLuint first, GLsizei count, const GLuint *textures);
GL_INVALID_OPERATION is generated if first + count is greater than the number of texture image units supported by the implementation. 
GL_INVALID_OPERATION is generated if any value in textures is not zero or the name of an existing texture object. 

void glBindTransformFeedback(GLenum target, GLuint id);
GL_INVALID_ENUM is generated if target is not GL_TRANSFORM_FEEDBACK. 
GL_INVALID_OPERATION is generated if the transform feedback operation is active on the currently bound transform feedback object, and that operation is not paused. 
GL_INVALID_OPERATION is generated if id is not zero or the name of a transform feedback object returned from a previous call to glGenTransformFeedbacks, or if such a name has been deleted by glDeleteTransformFeedbacks. 

void glBindVertexArray(GLuint array);
GL_INVALID_OPERATION is generated if array is not zero or the name of a vertex array object previously returned from a call to glGenVertexArrays. 

void glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLintptr stride);
GL_INVAILD_VALUE is generated if bindingindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIB_BINDINGS. 
GL_INVALID_VALUE is generated if offset or stride is less than zero. 
GL_INVALID_VALUE is generated if buffer is not the name of an existing buffer object. 
GL_INVALID_OPERATION is generated if no vertex array object is bound. 

void glBindVertexBuffers(GLuint first, GLsizei count, const GLuint *buffers, const GLuintptr *offsets, const GLsizei *strides);
GL_INVALID_OPERATION is generated if first + count is greater than the value of GL_MAX_VERTEX_ATTRIB_BINDINGS. 
GL_INVALID_OPERATION is generated if any value in buffers is not zero or the name of an existing buffer object. 
GL_INVALID_VALUE is generated if any value in offsets or strides is negative, or if a value is stride is greater than the value of GL_MAX_VERTEX_ATTRIB_STRIDE. 

void glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);

void glBlendEquation(GLenum mode);
GL_INVALID_ENUM is generated if mode is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MAX, or GL_MIN. 
GL_INVALID_VALUE is generated by glBlendEquationi if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS. 

void glBlendEquationi(GLuint buf, GLenum mode);
GL_INVALID_ENUM is generated if mode is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MAX, or GL_MIN. 
GL_INVALID_VALUE is generated by glBlendEquationi if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS. 

void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha);
GL_INVALID_ENUM is generated if either modeRGB or modeAlpha is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MAX, or GL_MIN. 
GL_INVALID_VALUE is generated by glBlendEquationSeparatei if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS. 

void glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha);
GL_INVALID_ENUM is generated if either modeRGB or modeAlpha is not one of GL_FUNC_ADD, GL_FUNC_SUBTRACT, GL_FUNC_REVERSE_SUBTRACT, GL_MAX, or GL_MIN. 
GL_INVALID_VALUE is generated by glBlendEquationSeparatei if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS. 

void glBlendFunc(GLenum sfactor, GLenum dfactor);
GL_INVALID_ENUM is generated if either sfactor or dfactor is not an accepted value. 
GL_INVALID_VALUE is generated by glBlendFunci if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS. 

void glBlendFunci(GLuint buf, GLenum sfactor, GLenum dfactor);
GL_INVALID_ENUM is generated if either sfactor or dfactor is not an accepted value. 
GL_INVALID_VALUE is generated by glBlendFunci if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS. 

void glBlendFuncSeparate(GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
GL_INVALID_ENUM is generated if either srcRGB or dstRGB is not an accepted value. 
GL_INVALID_VALUE is generated by glBlendFuncSeparatei if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS. 

void glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
GL_INVALID_ENUM is generated if either srcRGB or dstRGB is not an accepted value. 
GL_INVALID_VALUE is generated by glBlendFuncSeparatei if buf is greater than or equal to the value of GL_MAX_DRAW_BUFFERS. 

void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
GL_INVALID_OPERATION is generated if mask contains any of the GL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT and filter is not GL_NEAREST. 
GL_INVALID_OPERATION is generated if mask contains GL_COLOR_BUFFER_BIT and any of the following conditions hold: 
The read buffer contains fixed-point or floating-point values and any draw buffer contains neither fixed-point nor floating-point values.
The read buffer contains unsigned integer values and any draw buffer does not contain unsigned integer values.
The read buffer contains signed integer values and any draw buffer does not contain signed integer values.
GL_INVALID_OPERATION is generated if mask contains GL_DEPTH_BUFFER_BIT or GL_STENCIL_BUFFER_BIT and the source and destination depth and stencil formats do not match. 
GL_INVALID_OPERATION is generated if filter is GL_LINEAR and the read buffer contains integer data. 
GL_INVALID_OPERATION is generated if the value of GL_SAMPLES for the read and draw buffers is not identical. 
GL_INVALID_OPERATION is generated if GL_SAMPLE_BUFFERS for both read and draw buffers greater than zero and the dimensions of the source and destination rectangles is not identical. 
GL_INVALID_FRAMEBUFFER_OPERATION is generated if the objects bound to GL_DRAW_FRAMEBUFFER_BINDING or GL_READ_FRAMEBUFFER_BINDING are not framebuffer complete. 

void glBufferData(GLenum target, GLsizeiptr size, const GLvoid * data, GLenum usage);
GL_INVALID_ENUM is generated if target is not one of the accepted buffer targets. 
GL_INVALID_ENUM is generated if usage is not GL_STREAM_DRAW, GL_STREAM_READ, GL_STREAM_COPY, GL_STATIC_DRAW, GL_STATIC_READ, GL_STATIC_COPY, GL_DYNAMIC_DRAW, GL_DYNAMIC_READ, or GL_DYNAMIC_COPY. 
GL_INVALID_VALUE is generated if size is negative. 
GL_INVALID_OPERATION is generated if the reserved buffer object name 0 is bound to target. 
GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store with the specified size. 

void glBufferStorage(GLenum target, GLsizeiptr size, const GLvoid * data, GLbitfield flags);
GL_INVALID_ENUM is generated if target is not one of the accepted buffer targets. 
GL_INVALID_VALUE is generated if size is less than or equal to zero. 
GL_INVALID_OPERATION is generated if the reserved buffer object name 0 is bound to target. 
GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store with the properties requested in flags. 
GL_INVALID_VALUE is generated if flags has any bits set other than those defined above. 
GL_INVALID_VALUE error is generated if flags contains GL_MAP_PERSISTENT_BIT but does not contain at least one of GL_MAP_READ_BIT or GL_MAP_WRITE_BIT. 
GL_INVALID_VALUE is generated if flags contains GL_MAP_COHERENT_BIT, but does not also contain GL_MAP_PERSISTENT_BIT. 
GL_INVALID_OPERATION is generated if the GL_BUFFER_IMMUTABLE_STORAGE flag of the buffer bound to target is GL_TRUE. 

void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid * data);
GL_INVALID_ENUM is generated if target is not one of the accepted buffer targets. 
GL_INVALID_VALUE is generated if offset or size is negative, or if together they define a region of memory that extends beyond the buffer object's allocated data store. 
GL_INVALID_OPERATION is generated if the reserved buffer object name 0 is bound to target. 
GL_INVALID_OPERATION is generated if the buffer object being updated is mapped. 

GLenum glCheckFramebufferStatus(GLenum target);
GL_INVALID_ENUM is generated if target is not GL_DRAW_FRAMEBUFFER, GL_READ_FRAMEBUFFER or GL_FRAMEBUFFER. 

void glClampColor(GLenum target, GLenum clamp);
GL_INVALID_ENUM is generated if target is not GL_CLAMP_READ_COLOR. 
GL_INVALID_ENUM is generated if clamp is not GL_TRUE or GL_FALSE. 

void glClear(GLbitfield mask);
GL_INVALID_VALUE is generated if any bit other than the three defined bits is set in mask. 

void glClearBufferiv(GLenum buffer, GLint drawBuffer, const GLint * value);
GL_INVALID_ENUM is generated by glClearBufferif, glClearBufferfv and glClearBufferuiv if buffer is not GL_COLOR, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, GL_FRONT_AND_BACK, GL_DEPTH or GL_STENCIL. 
GL_INVALID_ENUM is generated by glClearBufferfi if buffer is not GL_DEPTH_STENCIL. 
GL_INVALID_VALUE is generated if buffer is GL_COLOR, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, or GL_FRONT_AND_BACK and drawBuffer is greater than or equal to GL_MAX_DRAW_BUFFERS. 
GL_INVALID_VALUE is generated if buffer is GL_DEPTH, GL_STENCIL or GL_DEPTH_STENCIL and drawBuffer is not zero. 

void glClearBufferuiv(GLenum buffer, GLint drawBuffer, const GLuint * value);
GL_INVALID_ENUM is generated by glClearBufferif, glClearBufferfv and glClearBufferuiv if buffer is not GL_COLOR, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, GL_FRONT_AND_BACK, GL_DEPTH or GL_STENCIL. 
GL_INVALID_ENUM is generated by glClearBufferfi if buffer is not GL_DEPTH_STENCIL. 
GL_INVALID_VALUE is generated if buffer is GL_COLOR, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, or GL_FRONT_AND_BACK and drawBuffer is greater than or equal to GL_MAX_DRAW_BUFFERS. 
GL_INVALID_VALUE is generated if buffer is GL_DEPTH, GL_STENCIL or GL_DEPTH_STENCIL and drawBuffer is not zero. 

void glClearBufferfv(GLenum buffer, GLint drawBuffer, const GLfloat * value);
GL_INVALID_ENUM is generated by glClearBufferif, glClearBufferfv and glClearBufferuiv if buffer is not GL_COLOR, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, GL_FRONT_AND_BACK, GL_DEPTH or GL_STENCIL. 
GL_INVALID_ENUM is generated by glClearBufferfi if buffer is not GL_DEPTH_STENCIL. 
GL_INVALID_VALUE is generated if buffer is GL_COLOR, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, or GL_FRONT_AND_BACK and drawBuffer is greater than or equal to GL_MAX_DRAW_BUFFERS. 
GL_INVALID_VALUE is generated if buffer is GL_DEPTH, GL_STENCIL or GL_DEPTH_STENCIL and drawBuffer is not zero. 

void glClearBufferfi(GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil);
GL_INVALID_ENUM is generated by glClearBufferif, glClearBufferfv and glClearBufferuiv if buffer is not GL_COLOR, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, GL_FRONT_AND_BACK, GL_DEPTH or GL_STENCIL. 
GL_INVALID_ENUM is generated by glClearBufferfi if buffer is not GL_DEPTH_STENCIL. 
GL_INVALID_VALUE is generated if buffer is GL_COLOR, GL_FRONT, GL_BACK, GL_LEFT, GL_RIGHT, or GL_FRONT_AND_BACK and drawBuffer is greater than or equal to GL_MAX_DRAW_BUFFERS. 
GL_INVALID_VALUE is generated if buffer is GL_DEPTH, GL_STENCIL or GL_DEPTH_STENCIL and drawBuffer is not zero. 

void glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void * data);
GL_INVALID_ENUM is generated if target not one of the generic buffer binding targets. 
GL_INVALID_VALUE is generated if no buffer is bound to target. 
GL_INVALID_ENUM is generated if internalformat is not a sized internal format. 
GL_INVALID_OPERATION is generated if any part of the buffer's data store is mapped with glMapBufferRange or glMapBuffer. 

void glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void * data);
GL_INVALID_ENUM is generated if target not one of the generic buffer binding targets. 
GL_INVALID_VALUE is generated if no buffer is bound to target. 
GL_INVALID_ENUM is generated if internalformat is not a sized internal format. 
GL_INVALID_VALUE is generated if offset or range are not multiples of the number of basic machine units per-element for the internal format specified by internalformat. 
GL_INVALID_VALUE is generated if offset or size is less than zero, or if offset + size is greater than the value of GL_BUFFER_SIZE for the buffer bound to target. 
GL_INVALID_OPERATION is generated if any part of the specified buffer range is mapped with glMapBufferRange or glMapBuffer. 

void glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);

void glClearDepth(GLdouble depth);

void glClearDepthf(GLfloat depth);

void glClearStencil(GLint s);

void glClearTexImage(GLuint texture, GLint level, GLenum format, GLenum type, const void * data);
GL_INVALID_OPERATION is generated if texture is zero or not the name of an existing texture object. 
GL_INVALID_OPERATION is generated if texture is a buffer texture. 
GL_INVALID_OPERATION is generated if texture has a compressed internal format. 
GL_INVALID_OPERATION is generated if the base internal format is GL_DEPTH_COMPONENT and format is not GL_DEPTH_COMPONENT. 
GL_INVALID_OPERATION is generated if the base internal format is GL_DEPTH_STENCIL and format is not GL_DEPTH_STENCIL. 
GL_INVALID_OPERATION is generated if the base internal format is GL_STENCIL_INDEX and format is not GL_STENCIL_INDEX. 
GL_INVALID_OPERATION is generated if the base internal format is GL_RGBA and format is GL_DEPTH_COMPONENT, GL_STENCIL_INDEX, or GL_DEPTH_STENCIL. 
GL_INVALID_OPERATION is generated if the internal format is integer and format does not specify integer data. 
GL_INVALID_OPERATION is generated if the internal format is not integer and format specifies integer data. 
GL_INVALID_OPERATION is generated if the image array identified by level has not previously been defined by a call to glTexImage* or glTexStorage*. 

void glClearTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void * data);
GL_INVALID_OPERATION is generated if texture is zero or not the name of an existing texture object. 
GL_INVALID_OPERATION is generated if texture is a buffer texture. 
GL_INVALID_OPERATION is generated if texture has a compressed internal format. 
GL_INVALID_OPERATION is generated if the base internal format is GL_DEPTH_COMPONENT and format is not GL_DEPTH_COMPONENT. 
GL_INVALID_OPERATION is generated if the base internal format is GL_DEPTH_STENCIL and format is not GL_DEPTH_STENCIL. 
GL_INVALID_OPERATION is generated if the base internal format is GL_STENCIL_INDEX and format is not GL_STENCIL_INDEX. 
GL_INVALID_OPERATION is generated if the base internal format is GL_RGBA and format is GL_DEPTH_COMPONENT, GL_STENCIL_INDEX, or GL_DEPTH_STENCIL. 
GL_INVALID_OPERATION is generated if the internal format is integer and format does not specify integer data. 
GL_INVALID_OPERATION is generated if the internal format is not integer and format specifies integer data. 
GL_INVALID_OPERATION error is generated if the xoffset, yoffset, zoffset, width, height, and depth parameters (or combinations thereof) specify a region that falls outside the defined texture image array (including border, if any). 

GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);
GL_INVALID_VALUE is generated if sync is not the name of an existing sync object. 
GL_INVALID_VALUE is generated if flags contains any unsupported flag. 

void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);

void glColorMaski(GLuint buf, GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);

void glCompileShader(GLuint shader);
GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if shader is not a shader object.

void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid * data);
GL_INVALID_ENUM is generated if internalformat is not a supported specific compressed internal formats, or is one of the generic compressed internal formats: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA. 
GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified compressed image data. 
GL_INVALID_VALUE is generated if border is not 0. 
GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with the extension specification defining the internal compression format. 

void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid * data);
GL_INVALID_ENUM is generated if internalformat is not one of the specific compressed internal formats: GL_COMPRESSED_RED_RGTC1, GL_COMPRESSED_SIGNED_RED_RGTC1, GL_COMPRESSED_RG_RGTC2, GL_COMPRESSED_SIGNED_RG_RGTC2. GL_COMPRESSED_RGBA_BPTC_UNORM, GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM, GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT, GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT, GL_COMPRESSED_RGB8_ETC2, GL_COMPRESSED_SRGB8_ETC2, GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2, GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2, GL_COMPRESSED_RGBA8_ETC2_EAC, GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC, GL_COMPRESSED_R11_EAC, GL_COMPRESSED_SIGNED_R11_EAC, GL_COMPRESSED_RG11_EAC, or GL_COMPRESSED_SIGNED_RG11_EAC. 
GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified compressed image data. 
GL_INVALID_VALUE is generated if border is not 0. 
GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with the extension specification defining the internal compression format. 

void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid * data);
GL_INVALID_ENUM is generated if internalformat is not one of the generic compressed internal formats: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA. 
GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified compressed image data. 
GL_INVALID_VALUE is generated if border is not 0. 
GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with the extension specification defining the internal compression format. 

void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid * data);
GL_INVALID_ENUM is generated if internalformat is not one of the generic compressed internal formats: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA. 
GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified compressed image data. 
GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with the extension specification defining the internal compression format. 

void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid * data);
GL_INVALID_ENUM is generated if internalformat is of the generic compressed internal formats: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA. 
GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified compressed image data. 
GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with the extension specification defining the internal compression format. 

void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid * data);
GL_INVALID_ENUM is generated if internalformat is one of the generic compressed internal formats: GL_COMPRESSED_RED, GL_COMPRESSED_RG, GL_COMPRESSED_RGB, GL_COMPRESSED_RGBA. GL_COMPRESSED_SRGB, or GL_COMPRESSED_SRGB_ALPHA. 
GL_INVALID_VALUE is generated if imageSize is not consistent with the format, dimensions, and contents of the specified compressed image data. 
GL_INVALID_OPERATION is generated if parameter combinations are not supported by the specific compressed internal format as specified in the specific texture compression extension. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
Undefined results, including abnormal program termination, are generated if data is not encoded in a manner consistent with the extension specification defining the internal compression format. 

void glCopyBufferSubData(GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);
GL_INVALID_VALUE is generated if any of readoffset, writeoffset or size is negative, if readoffset + size exceeds the size of the buffer object bound to readtarget or if writeoffset + size exceeds the size of the buffer object bound to writetarget. 
GL_INVALID_VALUE is generated if the same buffer object is bound to both readtarget and writetarget and the ranges [readoffset, readoffset + size) and [writeoffset, writeoffset + size) overlap. 
GL_INVALID_OPERATION is generated if zero is bound to readtarget or writetarget. 
GL_INVALID_OPERATION is generated if the buffer object bound to either readtarget or writetarget is mapped. 

void glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
GL_INVALID_OPERATION is generated if the texel size of the uncompressed image is not equal to the block size of the compressed image. 
GL_INVALID_ENUM is generated if either target parameter is not GL_RENDERBUFFER, a valid non-proxy texture target other than GL_TEXTURE_BUFFER, or is one of the cubemap face selectors. 
GL_INVALID_ENUM is generated if target does not match the type of the object. 
GL_INVALID_OPERATION is generated if either object is a texture and the texture is not complete. 
GL_INVALID_OPERATION is generated if the source and destination internal formats are not compatible, or if the number of samples do not match. 
GL_INVALID_VALUE is generated if either name does not correspond to a valid renderbuffer or texture object according to the corresponding target parameter. 
GL_INVALID_VALUE is generated if the specified level of either the source or destination is not a valid level for the corresponding image. 
GL_INVALID_VALUE is generated if the dimensions of the either subregion exceeds the boundaries of the corresponding image object, or if the image format is compressed and the dimensions of the subregion fail to meet the alignment constraints of the format. 

void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
GL_INVALID_ENUM is generated if target is not one of the allowable values. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level is greater than log 2 ⁢ max , where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if internalformat is not an allowable value. 
GL_INVALID_VALUE is generated if width is less than 0 or greater than GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if border is not 0. 
GL_INVALID_OPERATION is generated if internalformat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32 and there is no depth buffer. 

void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
GL_INVALID_ENUM is generated if target is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level is greater than log 2 ⁢ max , where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if width is less than 0 or greater than GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if border is not 0. 
GL_INVALID_VALUE is generated if internalformat is not an accepted format. 
GL_INVALID_OPERATION is generated if internalformat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32 and there is no depth buffer. 

void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
GL_INVALID_ENUM is generated if /target is not GL_TEXTURE_1D. 
GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage1D or glCopyTexImage1D operation. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level > log 2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if xoffset < 0 , or xoffset + width > w , where w is the GL_TEXTURE_WIDTH of the texture image being modified. 

void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
GL_INVALID_ENUM is generated if target is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY. 
GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage2D or glCopyTexImage2D operation. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level > log 2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if xoffset < 0 , xoffset + width > w , yoffset < 0 , or yoffset + height > 0 , where w is the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT and of the texture image being modified. 

void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
GL_INVALID_ENUM is generated if /target is not GL_TEXTURE_3D. 
GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage3D operation. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level > log 2 ⁡ max , where max is the returned value of GL_MAX_3D_TEXTURE_SIZE if target is GL_TEXTURE_3D or the returned value of GL_MAX_ARRAY_TEXTURE_LAYERS if target is GL_TEXTURE_2D_ARRAY. 
GL_INVALID_VALUE is generated if xoffset < 0 , xoffset + width > w , yoffset < 0 , yoffset + height > h , zoffset < 0 , or zoffset + 1 > d , where w is the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT, d is the GL_TEXTURE_DEPTH and of the texture image being modified. Note that w, h, and d include twice the border width. 

GLuint glCreateProgram(void);
This function returns 0 if an error occurs creating the program object.

GLuint glCreateShader(GLenum shaderType);
This function returns 0 if an error occurs creating the shader object.
GL_INVALID_ENUM is generated if shaderType is not an accepted value.

GLuint glCreateShaderProgramv(GLenum type, GLsizei count, const char **strings);
GL_INVALID_ENUM is generated if if type is not an accepted shader type. 
GL_INVALID_VALUE is generated if count is negative. 
Other errors are generated if the supplied shader code fails to compile and link, as described for the commands in the pseudocode sequence above, but all such errors are generated without any side effects of executing those commands. 

void glCullFace(GLenum mode);
GL_INVALID_ENUM is generated if mode is not an accepted value. 

void glDebugMessageCallback(DEBUGPROC callback, void * userParam);

void glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled);
GL_INVALID_VALUE is generated if count is negative. 
GL_INVALID_ENUM is generated if any of source, type or severity is not one of the accepted interface types. 
GL_INVALID_OPERATION is generated if count is non-zero and either source or type is GL_DONT_CARE or if severity is not GL_DONT_CARE. 

void glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const char *message);
GL_INVALID_ENUM is generated if any of source, type or severity is not one of the accepted interface types. 
GL_INVALID_VALUE is generated if the length of the message is greater than the value of GL_MAX_DEBUG_MESSAGE_LENGTH. 

void glDeleteBuffers(GLsizei n, const GLuint * buffers);
GL_INVALID_VALUE is generated if n is negative. 

void glDeleteFramebuffers(GLsizei n, GLuint *framebuffers);
GL_INVALID_VALUE is generated if n is negative. 

void glDeleteProgram(GLuint program);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.

void glDeleteProgramPipelines(GLsizei n, const GLuint *pipelines);

void glDeleteQueries(GLsizei n, const GLuint * ids);
GL_INVALID_VALUE is generated if n is negative. 

void glDeleteRenderbuffers(GLsizei n, GLuint *renderbuffers);
GL_INVALID_VALUE is generated if n is negative. 

void glDeleteSamplers(GLsizei n, const GLuint * samplers);
GL_INVALID_VALUE is generated if n is negative. 

void glDeleteShader(GLuint shader);
GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.

void glDeleteSync(GLsync sync);
GL_INVALID_VALUE is generated if sync is neither zero or the name of a sync object. 

void glDeleteTextures(GLsizei n, const GLuint * textures);
GL_INVALID_VALUE is generated if n is negative. 

void glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids);

void glDeleteVertexArrays(GLsizei n, const GLuint *arrays);
GL_INVALID_VALUE is generated if n is negative. 

void glDepthFunc(GLenum func);
GL_INVALID_ENUM is generated if func is not an accepted value. 

void glDepthMask(GLboolean flag);

void glDepthRange(GLdouble nearVal, GLdouble farVal);

void glDepthRangef(GLfloat nearVal, GLfloat farVal);

void glDepthRangeArrayv(GLuint first, GLsizei count, const GLdouble *v);
GL_INVALID_VALUE is generated if first is greater than or equal to the value of GL_MAX_VIEWPORTS. 
GL_INVALID_VALUE is generated if first + count is greater than or equal to the value of GL_MAX_VIEWPORTS. 

void glDepthRangeIndexed(GLuint index, GLdouble nearVal, GLdouble farVal);
GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_MAX_VIEWPORTS. 

void glDetachShader(GLuint program, GLuint shader);
GL_INVALID_VALUE is generated if either program or shader is a value that was not generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_OPERATION is generated if shader is not a shader object.
GL_INVALID_OPERATION is generated if shader is not attached to program.

void glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
GL_INVALID_OPERATION is generated if there is no active program for the compute shader stage. 
GL_INVALID_VALUE is generated if any of num_groups_x, num_groups_y, or num_groups_z is greater than or equal to the maximum work-group count for the corresponding dimension. 

void glDispatchComputeIndirect(GLintptr indirect);
GL_INVALID_OPERATION is generated if there is no active program for the compute shader stage. 
GL_INVALID_VALUE is generated if indirect is less than zero or not a multiple of four. 
GL_INVALID_OPERATION is generated if no buffer is bound to the GL_DISPATCH_INDIRECT_BUFFER target or if the command would source data beyond the end of the buffer object's data store. 

void glDrawArrays(GLenum mode, GLint first, GLsizei count);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if count is negative. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 

void glDrawArraysIndirect(GLenum mode, const void *indirect);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or to the GL_DRAW_INDIRECT_BUFFER binding and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active. 

void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei primcount);
GL_INVALID_ENUM is generated if mode is not one of the accepted values. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_VALUE is generated if count or primcount are negative. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped. 

void glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance);
GL_INVALID_ENUM is generated if mode is not one of the accepted values. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_VALUE is generated if count or primcount are negative. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped. 

void glDrawBuffer(GLenum mode);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_OPERATION is generated if none of the buffers indicated by mode exists. 

void glDrawBuffers(GLsizei n, const GLenum *bufs);
GL_INVALID_ENUM is generated if one of the values in bufs is not an accepted value.
GL_INVALID_ENUM is generated if the GL is bound to the default framebuffer and one or more of the values in bufs is one of the GL_COLOR_ATTACHMENTn tokens.
GL_INVALID_ENUM is generated if the GL is bound to a framebuffer object and one or more of the values in bufs is anything other than GL_NONE or one of the GL_COLOR_ATTACHMENTn tokens.
GL_INVALID_ENUM is generated if n is less than 0.
GL_INVALID_OPERATION is generated if a symbolic constant other than GL_NONE appears more than once in bufs.
GL_INVALID_OPERATION is generated if any of the entries in bufs (other than GL_NONE ) indicates a color buffer that does not exist in the current GL context.
GL_INVALID_VALUE is generated if n is greater than GL_MAX_DRAW_BUFFERS.

void glDrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if count is negative. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped. 

void glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, GLvoid *indices, GLint basevertex);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if count is negative. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped. 

void glDrawElementsIndirect(GLenum mode, GLenum type, const void *indirect);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_OPERATION is generated if no buffer is bound to the GL_ELEMENT_ARRAY_BUFFER binding, or if such a buffer's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or to the GL_DRAW_INDIRECT_BUFFER binding and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active. 

void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount);
GL_INVALID_ENUM is generated if mode is not one of GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, or GL_TRIANGLES. 
GL_INVALID_VALUE is generated if count or primcount are negative. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped. 

void glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const void * indices, GLsizei primcount, GLuitn baseinstance);
GL_INVALID_ENUM is generated if mode is not one of GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, or GL_TRIANGLES. 
GL_INVALID_VALUE is generated if count or primcount are negative. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped. 

void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, GLvoid *indices, GLsizei primcount, GLint basevertex);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if count or primcount is negative. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped. 

void glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, GLvoid *indices, GLsizei primcount, GLint basevertex, GLuint baseinstance);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if count or primcount is negative. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped. 

void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid * indices);
It is an error for indices to lie outside the range start end , but implementations may not check for this situation. Such indices cause implementation-dependent behavior. 
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if count is negative. 
GL_INVALID_VALUE is generated if end < start . 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped. 

void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, GLvoid *indices, GLint basevertex);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if count is negative. 
GL_INVALID_VALUE is generated if end < start. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped. 

void glDrawTransformFeedback(GLenum mode, GLuint id);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if id is not the name of a transform feedback object. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active. 
GL_INVALID_OPERATION is generated if glEndTransformFeedback has never been called while the transform feedback object named by id was bound. 

void glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei primcount);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if id is not the name of a transform feedback object. 
GL_INVALID_VALUE is generated if stream is greater than or equal to the value of GL_MAX_VERTEX_STREAMS. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active. 
GL_INVALID_OPERATION is generated if glEndTransformFeedback has never been called while the transform feedback object named by id was bound. 

void glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if id is not the name of a transform feedback object. 
GL_INVALID_VALUE is generated if stream is greater than or equal to the value of GL_MAX_VERTEX_STREAMS. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active. 
GL_INVALID_OPERATION is generated if glEndTransformFeedback has never been called while the transform feedback object named by id was bound. 

void glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei primcount);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if id is not the name of a transform feedback object. 
GL_INVALID_VALUE is generated if stream is greater than or equal to the value of GL_MAX_VERTEX_STREAMS. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active. 
GL_INVALID_OPERATION is generated if glEndTransformFeedback has never been called while the transform feedback object named by id was bound. 

void glEnable(GLenum cap);
GL_INVALID_ENUM is generated if cap is not one of the values listed previously. 
GL_INVALID_VALUE is generated by glEnablei and glDisablei if index is greater than or equal to the number of indexed capabilities for cap. 

void glDisable(GLenum cap);
GL_INVALID_ENUM is generated if cap is not one of the values listed previously. 
GL_INVALID_VALUE is generated by glEnablei and glDisablei if index is greater than or equal to the number of indexed capabilities for cap. 

void glEnablei(GLenum cap, GLuint index);
GL_INVALID_ENUM is generated if cap is not one of the values listed previously. 
GL_INVALID_VALUE is generated by glEnablei and glDisablei if index is greater than or equal to the number of indexed capabilities for cap. 

void glDisablei(GLenum cap, GLuint index);
GL_INVALID_ENUM is generated if cap is not one of the values listed previously. 
GL_INVALID_VALUE is generated by glEnablei and glDisablei if index is greater than or equal to the number of indexed capabilities for cap. 

void glEnableVertexAttribArray(GLuint index);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.

void glDisableVertexAttribArray(GLuint index);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.

GLsync glFenceSync(GLenum condition, GLbitfield flags);
GL_INVALID_ENUM is generated if condition is not GL_SYNC_GPU_COMMANDS_COMPLETE. 
GL_INVALID_VALUE is generated if flags is not zero. 
Additionally, if glFenceSync fails, it will return zero. 

void glFinish( void);

void glFlush( void);

void glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length);
GL_INVALID_VALUE is generated if offset or length is negative, or if offset + length exceeds the size of the mapping. 
GL_INVALID_OPERATION is generated if zero is bound to target. 
GL_INVALID_OPERATION is generated if the buffer bound to target is not mapped, or is mapped without the GL_MAP_FLUSH_EXPLICIT_BIT flag. 

void glFramebufferParameteri(GLenum target, GLenum pname, GLint param);
GL_INVALID_ENUM is generated if target is not one of the accepted framebuffer targets. 
GL_INVAILD_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_WIDTH and param is less than zero or greater than the value of GL_MAX_FRAMEBUFFER_WIDTH. 
GL_INVAILD_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_HEIGHT and param is less than zero or greater than the value of GL_MAX_FRAMEBUFFER_HEIGHT. 
GL_INVAILD_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_LAYERS and param is less than zero or greater than the value of GL_MAX_FRAMEBUFFER_LAYERS. 
GL_INVAILD_VALUE is generated if pname is GL_FRAMEBUFFER_DEFAULT_SAMPLES and param is less than zero or greater than the value of GL_MAX_FRAMEBUFFER_SAMPLES. 
GL_INVALID_OPERATION is generated if the default framebuffer is bound to target. 

void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
GL_INVALID_ENUM is generated if target is not one of the accepted tokens. 
GL_INVALID_ENUM is generated if renderbuffertarget is not GL_RENDERBUFFER. 
GL_INVALID_OPERATION is generated if zero is bound to target. 

void glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level);
GL_INVALID_ENUM is generated if target is not one of the accepted tokens. 
GL_INVALID_ENUM is generated if renderbuffertarget is not GL_RENDERBUFFER. 
GL_INVALID_OPERATION is generated if zero is bound to target. 
GL_INVALID_OPERATION is generated if textarget and texture are not compatible. 

void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
GL_INVALID_ENUM is generated if target is not one of the accepted tokens. 
GL_INVALID_ENUM is generated if renderbuffertarget is not GL_RENDERBUFFER. 
GL_INVALID_OPERATION is generated if zero is bound to target. 
GL_INVALID_OPERATION is generated if textarget and texture are not compatible. 

void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
GL_INVALID_ENUM is generated if target is not one of the accepted tokens. 
GL_INVALID_ENUM is generated if renderbuffertarget is not GL_RENDERBUFFER. 
GL_INVALID_OPERATION is generated if zero is bound to target. 
GL_INVALID_OPERATION is generated if textarget and texture are not compatible. 

void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer);
GL_INVALID_ENUM is generated if target is not one of the accepted tokens. 
GL_INVALID_ENUM is generated if renderbuffertarget is not GL_RENDERBUFFER. 
GL_INVALID_OPERATION is generated if zero is bound to target. 
GL_INVALID_OPERATION is generated if textarget and texture are not compatible. 

void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
GL_INVALID_ENUM is generated if target is not one of the accepted tokens. 
GL_INVALID_ENUM is generated if attachment is not one of the accepted tokens. 
GL_INVALID_VALUE is generated if texture is not zero or the name of an existing texture object. 
GL_INVALID_VALUE is generated if texture is not zero and layer is negative. 
GL_INVALID_OPERATION is generated if zero is bound to target. 
GL_INVALID_OPERATION is generated if texture is not zero or the name of an existing cube map texture. 

void glFrontFace(GLenum mode);
GL_INVALID_ENUM is generated if mode is not an accepted value. 

void glGenBuffers(GLsizei n, GLuint * buffers);
GL_INVALID_VALUE is generated if n is negative. 

void glGenFramebuffers(GLsizei n, GLuint *ids);
GL_INVALID_VALUE is generated if n is negative. 

void glGenProgramPipelines(GLsizei n, GLuint *pipelines);

void glGenQueries(GLsizei n, GLuint * ids);
GL_INVALID_VALUE is generated if n is negative. 

void glGenRenderbuffers(GLsizei n, GLuint *renderbuffers);
GL_INVALID_VALUE is generated if n is negative. 

void glGenSamplers(GLsizei n, GLuint *samplers);
GL_INVALID_VALUE is generated if n is negative. 

void glGenTextures(GLsizei n, GLuint * textures);
GL_INVALID_VALUE is generated if n is negative. 

void glGenTransformFeedbacks(GLsizei n, GLuint *ids);

void glGenVertexArrays(GLsizei n, GLuint *arrays);
GL_INVALID_VALUE is generated if n is negative. 

void glGenerateMipmap(GLenum target);
GL_INVALID_ENUM is generated if target is not one of the accepted texture targets. 
GL_INVALID_OPERATION is generated if target is GL_TEXTURE_CUBE_MAP and the texture bound to the GL_TEXTURE_CUBE_MAP target of the active texture unit is not cube complete. 

void glGetBooleanv(GLenum pname, GLboolean * params);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated on any of glGetBooleani_v, glGetIntegeri_v, or glGetInteger64i_v if index is outside of the valid range for the indexed state target. 

void glGetDoublev(GLenum pname, GLdouble * params);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated on any of glGetBooleani_v, glGetIntegeri_v, or glGetInteger64i_v if index is outside of the valid range for the indexed state target. 

void glGetFloatv(GLenum pname, GLfloat * params);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated on any of glGetBooleani_v, glGetIntegeri_v, or glGetInteger64i_v if index is outside of the valid range for the indexed state target. 

void glGetIntegerv(GLenum pname, GLint * params);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated on any of glGetBooleani_v, glGetIntegeri_v, or glGetInteger64i_v if index is outside of the valid range for the indexed state target. 

void glGetInteger64v(GLenum pname, GLint64 * params);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated on any of glGetBooleani_v, glGetIntegeri_v, or glGetInteger64i_v if index is outside of the valid range for the indexed state target. 

void glGetBooleani_v(GLenum pname, GLuint index, GLboolean * data);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated on any of glGetBooleani_v, glGetIntegeri_v, or glGetInteger64i_v if index is outside of the valid range for the indexed state target. 

void glGetIntegeri_v(GLenum pname, GLuint index, GLint * data);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated on any of glGetBooleani_v, glGetIntegeri_v, or glGetInteger64i_v if index is outside of the valid range for the indexed state target. 

void glGetFloati_v(GLenum pname, GLuint index, GLfloat * data);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated on any of glGetBooleani_v, glGetIntegeri_v, or glGetInteger64i_v if index is outside of the valid range for the indexed state target. 

void glGetDoublei_v(GLenum pname, GLuint index, GLdouble * data);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated on any of glGetBooleani_v, glGetIntegeri_v, or glGetInteger64i_v if index is outside of the valid range for the indexed state target. 

void glGetInteger64i_v(GLenum pname, GLuint index, GLint64 * data);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated on any of glGetBooleani_v, glGetIntegeri_v, or glGetInteger64i_v if index is outside of the valid range for the indexed state target. 

void glGetActiveAtomicCounterBufferiv(Gluint program, GLuint bufferIndex, GLenum pname, GLint *params);
GL_INVALID_VALUE is generated if program is not the name of a program object for which glLinkProgram has been called in the past. 
GL_INVALID_VALUE is generated if bufferIndex is greater than or equal to the value of GL_ACTIVE_ATOMIC_COUNTER_BUFFERS for program. 
GL_INVALID_ENUM is generated if pname is not one of the accepted tokens. 

void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_VALUE is generated if index is greater than or equal to the number of active attribute variables in program.
GL_INVALID_VALUE is generated if bufSize is less than 0.

void glGetActiveSubroutineName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name);
GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_ACTIVE_SUBROUTINES. 
GL_INVALID_VALUE is generated if program is not the name of an existing program object. 

void glGetActiveSubroutineUniformiv(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values);
GL_INVALID_ENUM is generated if shadertype or pname is not one of the accepted values. 
GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_ACTIVE_SUBROUTINES. 
GL_INVALID_VALUE is generated if program is not the name of an existing program object. 

void glGetActiveSubroutineUniformName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei *length, GLchar *name);
GL_INVALID_ENUM is generated if shadertype or pname is not one of the accepted values. 
GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_ACTIVE_SUBROUTINES. 
GL_INVALID_VALUE is generated if program is not the name of an existing program object. 

void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLint *size, GLenum *type, GLchar *name);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_VALUE is generated if index is greater than or equal to the number of active uniform variables in program.
GL_INVALID_VALUE is generated if bufSize is less than 0.

void glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint *params);
GL_INVALID_VALUE is generated if uniformBlockIndex is greater than or equal to the value of GL_ACTIVE_UNIFORM_BLOCKS or is not the index of an active uniform block in program. 
GL_INVALID_ENUM is generated if pname is not one of the accepted tokens. 
GL_INVALID_OPERATION is generated if program is not the name of a program object for which glLinkProgram has been called in the past. 

void glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformBlockName);
GL_INVALID_OPERATION is generated if program is not the name of a program object for which glLinkProgram has been called in the past. 
GL_INVALID_VALUE is generated if uniformBlockIndex is greater than or equal to the value of GL_ACTIVE_UNIFORM_BLOCKS or is not the index of an active uniform block in program. 

void glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei *length, GLchar *uniformName);
GL_INVALID_VALUE is generated if uniformIndex is greater than or equal to the value of GL_ACTIVE_UNIFORMS. 
GL_INVALID_VALUE is generated if bufSize is negative. 
GL_INVALID_VALUE is generated if program is not the name of a program object for which glLinkProgram has been issued. 

void glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint *uniformIndices, GLenum pname, GLint *params);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_VALUE is generated if uniformCount is greater than or equal to the value of GL_ACTIVE_UNIFORMS for program.
GL_INVALID_ENUM is generated if pname is not an accepted token.

void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei *count, GLuint *shaders);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_VALUE is generated if maxCount is less than 0.

GLint glGetAttribLocation(GLuint program, const GLchar *name);
GL_INVALID_OPERATION is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_OPERATION is generated if program has not been successfully linked.

void glGetBufferParameteriv(GLenum target, GLenum value, GLint * data);
GL_INVALID_ENUM is generated if target or value is not an accepted value. 
GL_INVALID_OPERATION is generated if the reserved buffer object name 0 is bound to target. 

void glGetBufferParameteri64v(GLenum target, GLenum value, GLint64 * data);
GL_INVALID_ENUM is generated if target or value is not an accepted value. 
GL_INVALID_OPERATION is generated if the reserved buffer object name 0 is bound to target. 

void glGetBufferPointerv(GLenum target, GLenum pname, GLvoid ** params);
GL_INVALID_ENUM is generated if target or pname is not an accepted value. 
GL_INVALID_OPERATION is generated if the reserved buffer object name 0 is bound to target. 

void glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, GLvoid * data);
GL_INVALID_ENUM is generated if target is not GL_ARRAY_BUFFER, GL_ELEMENT_ARRAY_BUFFER, GL_PIXEL_PACK_BUFFER, or GL_PIXEL_UNPACK_BUFFER. 
GL_INVALID_VALUE is generated if offset or size is negative, or if together they define a region of memory that extends beyond the buffer object's allocated data store. 
GL_INVALID_OPERATION is generated if the reserved buffer object name 0 is bound to target. 
GL_INVALID_OPERATION is generated if the buffer object being queried is mapped. 

void glGetCompressedTexImage(GLenum target, GLint lod, GLvoid * img);
GL_INVALID_VALUE is generated if lod is less than zero or greater than the maximum number of LODs permitted by the implementation. 
GL_INVALID_OPERATION is generated if glGetCompressedTexImage is used to retrieve a texture that is in an uncompressed internal format. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data would be packed to the buffer object such that the memory writes required would exceed the data store size. 

GLuint glGetDebugMessageLog(GLuint count, GLsizei bufSize, GLenum *sources, Glenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog);
GL_INVALID_VALUE is generated if count or bufSize is negative. 

GLenum glGetError( void);

GLint glGetFragDataIndex(GLuint program, const char * name);
GL_INVALID_OPERATION is generated if program is not the name of a program object. 

GLint glGetFragDataLocation(GLuint program, const char * name);
GL_INVALID_OPERATION is generated if program is not the name of a program object. 

void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint *params);
GL_INVALID_ENUM is generated if target is not one of the accepted tokens. 
GL_INVALID_ENUM is generated if pname is not valid for the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE. 
GL_INVALID_OPERATION is generated if attachment is not the accepted values for target. 
GL_INVALID_OPERATION is generated if attachment is GL_DEPTH_STENCIL_ATTACHMENT and different objects are bound to the depth and stencil attachment points of target. 
GL_INVALID_OPERATION is generated if the value of GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE is GL_NONE and pname is not GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME. 

void glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint * params);
GL_INVALID_ENUM is generated if target is not one of the accepted framebuffer targets. 
GL_INVALID_ENUM is generated if pname is not one of the accepted parameter names. 
GL_INVALID_OPERATION is generated if the default framebuffer is bound to target. 
params should be the address of a variable to which the client has write access otherwise undefined behavior, including process termination may occur. 

void glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint *params);
GL_INVALID_VALUE is generated if bufSize is negative. 
GL_INVALID_ENUM is generated if pname is not GL_SAMPLES or GL_NUM_SAMPLE_COUNTS. 
GL_INVALID_ENUM is generated if internalformat is not color-, depth-, or stencil-renderable. 
GL_INVALID_ENUM is generated if target is not one of GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_RENDERBUFFER. 

void glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64 *params);
GL_INVALID_VALUE is generated if bufSize is negative. 
GL_INVALID_ENUM is generated if pname is not GL_SAMPLES or GL_NUM_SAMPLE_COUNTS. 
GL_INVALID_ENUM is generated if internalformat is not color-, depth-, or stencil-renderable. 
GL_INVALID_ENUM is generated if target is not one of GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_2D_MULTISAMPLE_ARRAY or GL_RENDERBUFFER. 

void glGetMultisamplefv(GLenum pname, GLuint index, GLfloat *val);
GL_INVALID_ENUM is generated if pname is not one GL_SAMPLE_POSITION. 
GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_SAMPLES. 

void glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bifSize, GLsizei * length, char * label);
GL_INVALID_ENUM is generated if identifier is not one of the accepted object types. 
GL_INVALID_OPERATION is generated if name is not the name of an existing object of the type specified by identifier. 
GL_INVALID_VALUE is generated if bufSize is zero. 
If not NULL, length and label should be addresses to which the client has write access, otherwise undefined behavior, including process termination may occur. 

void glGetObjectPtrLabel(void * ptr, GLsizei bifSize, GLsizei * length, char * label);
GL_INVALID_ENUM is generated if identifier is not one of the accepted object types. 
GL_INVALID_VALUE is generated if ptr is not the name of an existing sync object. 
GL_INVALID_VALUE is generated if bufSize is zero. 
If not NULL, length and label should be addresses to which the client has write access, otherwise undefined behavior, including process termination may occur. 

void glGetProgramiv(GLuint program, GLenum pname, GLint *params);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program does not refer to a program object.
GL_INVALID_OPERATION is generated if pname is GL_GEOMETRY_VERTICES_OUT, GL_GEOMETRY_INPUT_TYPE, or GL_GEOMETRY_OUTPUT_TYPE, and program does not contain a geometry shader.
GL_INVALID_ENUM is generated if pname is not an accepted value.
GL_INVALID_OPERATION is generated if pname is GL_COMPUTE_WORK_GROUP_SIZE and program does not contain a binary for the compute shader stage.

void glGetProgramBinary(GLuint program, GLsizei bufsize, GLsizei *length, GLenum *binaryFormat, void *binary);
GL_INVALID_OPERATION is generated if bufSize is less than the size of GL_PROGRAM_BINARY_LENGTH for program. 
GL_INVALID_OPERATION is generated if GL_LINK_STATUS for the program object is false. 

void glGetProgramInfoLog(GLuint program, GLsizei maxLength, GLsizei *length, GLchar *infoLog);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_VALUE is generated if maxLength is less than 0.

void glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint * params);
GL_INVALID_ENUM is generated if identifier is not one of the accepted object types. 
GL_INVALID_VALUE is generated if program is not the name of an existing sync object. 
GL_INVALID_VALUE is generated if bufSize is zero. 
GL_INVALID_OPERATION is generated if pname is GL_MAX_NAME_LENGTH and programInterface is GL_ATOMIC_COUNTER_BUFFER or GL_TRANSFORM_FEEDBACK_BUFFER, since active atomic counter and transform feedback buffer resources are not assigned name strings. 
GL_INVALID_OPERATION error is generated if pname is GL_MAX_NUM_ACTIVE_VARIABLES and programInterface is not GL_UNIFORM_BLOCK, GL_SHADER_STORAGE_BLOCK, GL_ATOMIC_COUNTER_BUFFER, or GL_TRANSFORM_FEEDBACK_BUFFER. 
If not NULL, length and label should be addresses to which the client has write access, otherwise undefined behavior, including process termination may occur. 

void glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint *params);
GL_INVALID_OPERATION is generated if pipeline is not zero or a name previously returned from a call to glGenProgramPipelines or if such a name has been deleted by a call to glDeleteProgramPipelines. 
GL_INVALID_ENUM is generated if pname is not one of the accepted values. 

void glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog);
GL_INVALID_OPERATION is generated if pipeline is not a name previously returned from a call to glGenProgramPipelines or if such a name has been deleted by a call to glDeleteProgramPipelines. 

void glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const Glenum * props, GLsizei bufSize, GLsizei * length, GLint * params);
GL_INVALID_VALUE is generated if program is not the name of an existing program object. 
GL_INVALID_VALUE is generated if propCount is zero. 
GL_INVALID_ENUM is generated if programInterface is not one of the accepted interface types. 
GL_INVLALID_ENUM is generated if any value in props is not one of the accepted tokens for the interface programInterface 

GLuint glGetProgramResourceIndex(GLuint program, GLenum programInterface, const char * name);
GL_INVALID_ENUM is generated if programInterface is not one of the accepted interface types. 
GL_INVALID_ENUM is generated if programInterface is GL_ATOMIC_COUNTER_BUFFER or GL_TRANSFORM_FEEDBACK_BUFFER, since active atomic counter and transform feedback buffer resources are not assigned name strings. 
Although not an error, GL_INVALID_INDEX is returned if name is not the name of a resource within the interface identified by programInterface. 

GLint glGetProgramResourceLocation(GLuint program, GLenum programInterface, const char * name);
GL_INVALID_VALUE is generated if program is not the name of an existing program object. 
GL_INVALID_ENUM is generated if programInterface is not one of the accepted interface types. 
GL_INVALID_OPERATION is generated if program has not been linked successfully. 

GLint glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const char * name);
GL_INVALID_VALUE is generated if program is not the name of an existing program object. 
GL_INVALID_ENUM is generated if programInterface is not one of the accepted interface types. 
GL_INVALID_OPERATION is generated if program has not been linked successfully. 

void glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei * length, char * name);
GL_INVALID_ENUM is generated if programInterface is not one of the accepted interface types. 
GL_INVALID_VALUE is generated if progam is not the name of an existing program. 
GL_INVALID_VALUE is generated if index is greater than or equal to the number of entries in the active resource list for programInterface. 
GL_INVALID_ENUM is generated if programInterface is GL_ATOMIC_COUNTER_BUFFER or GL_TRANSFORM_FEEDBACK_BUFFER, since active atomic counter and transform feedback buffer resources are not assigned name strings. 

void glGetProgramStageiv(GLuint program, GLenum shadertype, GLenum pname, GLint *values);
GL_INVALID_ENUM is generated if shadertype or pname is not one of the accepted values. 
GL_INVALID_VALUE is generated if program is not the name of an existing program object. 

void glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint * params);
GL_INVALID_ENUM is generated if target or pname is not an accepted value. 
GL_INVALID_VALUE is generated if index is greater than or equal to the target-specific maximum. 

void glGetQueryObjectiv(GLuint id, GLenum pname, GLint * params);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_OPERATION is generated if id is not the name of a query object. 
GL_INVALID_OPERATION is generated if id is the name of a currently active query object. 
GL_INVALID_OPERATION is generated if a buffer is currently bound to the GL_QUERY_RESULT_BUFFER target and the command would cause data to be written beyond the bounds of that buffer's data store. 

void glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint * params);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_OPERATION is generated if id is not the name of a query object. 
GL_INVALID_OPERATION is generated if id is the name of a currently active query object. 
GL_INVALID_OPERATION is generated if a buffer is currently bound to the GL_QUERY_RESULT_BUFFER target and the command would cause data to be written beyond the bounds of that buffer's data store. 

void glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64 * params);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_OPERATION is generated if id is not the name of a query object. 
GL_INVALID_OPERATION is generated if id is the name of a currently active query object. 
GL_INVALID_OPERATION is generated if a buffer is currently bound to the GL_QUERY_RESULT_BUFFER target and the command would cause data to be written beyond the bounds of that buffer's data store. 

void glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64 * params);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_OPERATION is generated if id is not the name of a query object. 
GL_INVALID_OPERATION is generated if id is the name of a currently active query object. 
GL_INVALID_OPERATION is generated if a buffer is currently bound to the GL_QUERY_RESULT_BUFFER target and the command would cause data to be written beyond the bounds of that buffer's data store. 

void glGetQueryiv(GLenum target, GLenum pname, GLint * params);
GL_INVALID_ENUM is generated if target or pname is not an accepted value. 

void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint *params);
GL_INVALID_ENUM is generated if pname is not one of the accepted tokens. 

void glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat * params);
GL_INVALID_VALUE is generated if sampler is not the name of a sampler object returned from a previous call to glGenSamplers. 
GL_INVALID_ENUM is generated if pname is not an accepted value. 

void glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint * params);
GL_INVALID_VALUE is generated if sampler is not the name of a sampler object returned from a previous call to glGenSamplers. 
GL_INVALID_ENUM is generated if pname is not an accepted value. 

void glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint * params);
GL_INVALID_VALUE is generated if sampler is not the name of a sampler object returned from a previous call to glGenSamplers. 
GL_INVALID_ENUM is generated if pname is not an accepted value. 

void glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint * params);
GL_INVALID_VALUE is generated if sampler is not the name of a sampler object returned from a previous call to glGenSamplers. 
GL_INVALID_ENUM is generated if pname is not an accepted value. 

void glGetShaderiv(GLuint shader, GLenum pname, GLint *params);
GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if shader does not refer to a shader object.
GL_INVALID_ENUM is generated if pname is not an accepted value.

void glGetShaderInfoLog(GLuint shader, GLsizei maxLength, GLsizei *length, GLchar *infoLog);
GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if shader is not a shader object.
GL_INVALID_VALUE is generated if maxLength is less than 0.

void glGetShaderPrecisionFormat(GLenum shaderType, GLenum precisionType, GLint *range, GLint *precision);
GL_INVALID_ENUM is generated if shaderType or precisionType is not an accepted value. 

void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei *length, GLchar *source);
GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if shader is not a shader object.
GL_INVALID_VALUE is generated if bufSize is less than 0.

const GLubyte* glGetString(GLenum name);
GL_INVALID_ENUM is generated if name is not an accepted value. 
GL_INVALID_VALUE is generated by glGetStringi if index is outside the valid range for indexed state name. 

const GLubyte* glGetStringi(GLenum name, GLuint index);
GL_INVALID_ENUM is generated if name is not an accepted value. 
GL_INVALID_VALUE is generated by glGetStringi if index is outside the valid range for indexed state name. 

GLuint glGetSubroutineIndex(GLuint program, GLenum shadertype, const GLchar *name);
GL_INVALID_ENUM is generated if shadertype or pname is not one of the accepted values. 
GL_INVALID_VALUE is generated if program is not the name of an existing program object. 

GLint glGetSubroutineUniformLocation(GLuint program, GLenum shadertype, const GLchar *name);
GL_INVALID_ENUM is generated if shadertype or pname is not one of the accepted values. 
GL_INVALID_VALUE is generated if program is not the name of an existing program object. 

void glGetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei *length, GLint *values);
GL_INVALID_VALUE is generated if sync is not the name of a sync object. 
GL_INVALID_ENUM is generated if pname is not one of the accepted tokens. 

void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLvoid * img);
GL_INVALID_ENUM is generated if target, format, or type is not an accepted value. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level is greater than log 2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV and format is not GL_RGB. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_5_9_9_9_REV and format is neither GL_RGBA or GL_BGRA. 
GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX or GL_DEPTH_STENCIL. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data would be packed to the buffer object such that the memory writes required would exceed the data store size. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and img is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type. 

void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat * params);
GL_INVALID_ENUM is generated if target or pname is not an accepted value. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level is greater than log 2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if target is GL_TEXTURE_BUFFER and level is not zero. 
GL_INVALID_OPERATION is generated if GL_TEXTURE_COMPRESSED_IMAGE_SIZE is queried on texture images with an uncompressed internal format or on proxy targets. 

void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint * params);
GL_INVALID_ENUM is generated if target or pname is not an accepted value. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level is greater than log 2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if target is GL_TEXTURE_BUFFER and level is not zero. 
GL_INVALID_OPERATION is generated if GL_TEXTURE_COMPRESSED_IMAGE_SIZE is queried on texture images with an uncompressed internal format or on proxy targets. 

void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat * params);
GL_INVALID_ENUM is generated if target or pname is not an accepted value. 

void glGetTexParameteriv(GLenum target, GLenum pname, GLint * params);
GL_INVALID_ENUM is generated if target or pname is not an accepted value. 

void glGetTexParameterIiv(GLenum target, GLenum pname, GLint * params);
GL_INVALID_ENUM is generated if target or pname is not an accepted value. 

void glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint * params);
GL_INVALID_ENUM is generated if target or pname is not an accepted value. 

void glGetTransformFeedbackVarying(GLuintprogram, GLuintindex, GLsizeibufSize, GLsizei *length, GLsizei *size, GLenum *type, char *name);
GL_INVALID_VALUE is generated if program is not the name of a program object. 
GL_INVALID_VALUE is generated if index is greater or equal to the value of GL_TRANSFORM_FEEDBACK_VARYINGS. 
GL_INVALID_OPERATION is generated program has not been linked. 

void glGetUniformfv(GLuint program, GLint location, GLfloat *params);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_OPERATION is generated if program has not been successfully linked.
GL_INVALID_OPERATION is generated if location does not correspond to a valid uniform variable location for the specified program object.

void glGetUniformiv(GLuint program, GLint location, GLint *params);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_OPERATION is generated if program has not been successfully linked.
GL_INVALID_OPERATION is generated if location does not correspond to a valid uniform variable location for the specified program object.

void glGetUniformuiv(GLuint program, GLint location, GLuint *params);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_OPERATION is generated if program has not been successfully linked.
GL_INVALID_OPERATION is generated if location does not correspond to a valid uniform variable location for the specified program object.

void glGetUniformdv(GLuint program, GLint location, GLdouble *params);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_OPERATION is generated if program has not been successfully linked.
GL_INVALID_OPERATION is generated if location does not correspond to a valid uniform variable location for the specified program object.

GLuint glGetUniformBlockIndex(GLuint program, const GLchar *uniformBlockName);
GL_INVALID_OPERATION is generated if program is not the name of a program object for which glLinkProgram has been called in the past. 

void glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar **uniformNames, GLuint *uniformIndices);
GL_INVALID_OPERATION is generated if program is not the name of a program object for which glLinkProgram has been called in the past. 

GLint glGetUniformLocation(GLuint program, const GLchar *name);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_OPERATION is generated if program has not been successfully linked.

void glGetUniformSubroutineuiv(GLenum shadertype, GLint location, GLuint *values);
GL_INVALID_ENUM is generated if shadertype is not one of the accepted values. 
GL_INVALID_VALUE is generated if location is greater than or equal to the value of GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS for the shader currently in use at shader stage shadertype. 
GL_INVALID_OPERATION is generated if no program is active. 

void glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params);
GL_INVALID_OPERATION is generated if pname is not GL_CURRENT_VERTEX_ATTRIB and there is no currently bound vertex array object.
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if pname is not an accepted value.
GL_INVALID_OPERATION is generated if index is 0 and pname is GL_CURRENT_VERTEX_ATTRIB.

void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params);
GL_INVALID_OPERATION is generated if pname is not GL_CURRENT_VERTEX_ATTRIB and there is no currently bound vertex array object.
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if pname is not an accepted value.
GL_INVALID_OPERATION is generated if index is 0 and pname is GL_CURRENT_VERTEX_ATTRIB.

void glGetVertexAttribiv(GLuint index, GLenum pname, GLint *params);
GL_INVALID_OPERATION is generated if pname is not GL_CURRENT_VERTEX_ATTRIB and there is no currently bound vertex array object.
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if pname is not an accepted value.
GL_INVALID_OPERATION is generated if index is 0 and pname is GL_CURRENT_VERTEX_ATTRIB.

void glGetVertexAttribIiv(GLuint index, GLenum pname, GLint *params);
GL_INVALID_OPERATION is generated if pname is not GL_CURRENT_VERTEX_ATTRIB and there is no currently bound vertex array object.
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if pname is not an accepted value.
GL_INVALID_OPERATION is generated if index is 0 and pname is GL_CURRENT_VERTEX_ATTRIB.

void glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params);
GL_INVALID_OPERATION is generated if pname is not GL_CURRENT_VERTEX_ATTRIB and there is no currently bound vertex array object.
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if pname is not an accepted value.
GL_INVALID_OPERATION is generated if index is 0 and pname is GL_CURRENT_VERTEX_ATTRIB.

void glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble *params);
GL_INVALID_OPERATION is generated if pname is not GL_CURRENT_VERTEX_ATTRIB and there is no currently bound vertex array object.
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if pname is not an accepted value.
GL_INVALID_OPERATION is generated if index is 0 and pname is GL_CURRENT_VERTEX_ATTRIB.

void glGetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid **pointer);
GL_INVALID_OPERATION is generated if no vertex array object is currently bound.
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if pname is not an accepted value.

void glHint(GLenum target, GLenum mode);
GL_INVALID_ENUM is generated if either target or mode is not an accepted value. 

void glInvalidateBufferData(GLuint buffer);
GL_INVALID_VALUE is generated if buffer is not the name of an existing buffer object. 
GL_INVALID_OPERATION is generated if any part of buffer is currently mapped. 

void glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length);
GL_INVALID_VALUE is generated if offset or length is negative, or if offset + length is greater than the value of GL_BUFFER_SIZE for buffer. 
GL_INVALID_VALUE is generated if buffer is not the name of an existing buffer object. 
GL_INVALID_OPERATION is generated if any part of buffer is currently mapped. 

void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments);
GL_INVALID_ENUM is generated if target is not one of the accepted framebuffer target tokens. 
GL_INVALID_ENUM is generated if any element of attachments is not one of the accepted framebuffer attachment tokens. 
GL_INVALID_OPERATION is generated if element of attachments is GL_COLOR_ATTACHMENTi where i is greater than or equal to the value of GL_MAX_COLOR_ATTACHMENTS. 

void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum * attachments, GLint x, GLint y, GLint width, GLint height);
GL_INVALID_ENUM is generated if target is not one of the accepted framebuffer target tokens. 
GL_INVALID_ENUM is generated if any element of attachments is not one of the accepted framebuffer attachment tokens. 
GL_INVALID_OPERATION is generated if element of attachments is GL_COLOR_ATTACHMENTi where i is greater than or equal to the value of GL_MAX_COLOR_ATTACHMENTS. 

void glInvalidateTexImage(GLuint texture, GLint level);
GL_INVALID_VALUE is generated if level is less than zero or if it is greater or equal to the base 2 logarithm of the maximum texture width, height, or depth. 
GL_INVALID_VALUE is generated if the target of texture is any of GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE, or GL_TEXTURE_2D_MULTISAMPLE_ARRAY and level is not zero. 
GL_INVALID_VALUE is generated if texture is not the name of an existing texture object. 

void glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
GL_INVALID_VALUE is generated if xoffset, yoffset or zoffset is less than zero, or if any of them is greater than the size of the image in the corresponding dimension. 
GL_INVALID_VALUE is generated if level is less than zero or if it is greater or equal to the base 2 logarithm of the maximum texture width, height, or depth. 
GL_INVALID_VALUE is generated if the target of texture is any of GL_TEXTURE_RECTANGLE, GL_TEXTURE_BUFFER, GL_TEXTURE_2D_MULTISAMPLE, or GL_TEXTURE_2D_MULTISAMPLE_ARRAY and level is not zero. 
GL_INVALID_VALUE is generated if texture is not the name of an existing texture object. 

GLboolean glIsBuffer(GLuint buffer);

GLboolean glIsEnabled(GLenum cap);
GL_INVALID_ENUM is generated if cap is not an accepted value. 
GL_INVALID_VALUE is generated by glIsEnabledi if index is outside the valid range for the indexed state cap. 

GLboolean glIsEnabledi(GLenum cap, GLuint index);
GL_INVALID_ENUM is generated if cap is not an accepted value. 
GL_INVALID_VALUE is generated by glIsEnabledi if index is outside the valid range for the indexed state cap. 

GLboolean glIsFramebuffer(GLuint framebuffer);

GLboolean glIsProgram(GLuint program);

GLboolean glIsProgramPipeline(GLuint pipeline);

GLboolean glIsQuery(GLuint id);

GLboolean glIsRenderbuffer(GLuint renderbuffer);

GLboolean glIsSampler(GLuint id);

GLboolean glIsShader(GLuint shader);

GLboolean glIsSync(GLsync sync);

GLboolean glIsTexture(GLuint texture);

GLboolean glIsTransformFeedback(GLuint id);

GLboolean glIsVertexArray(GLuint array);

void glLineWidth(GLfloat width);
GL_INVALID_VALUE is generated if width is less than or equal to 0. 

void glLinkProgram(GLuint program);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_OPERATION is generated if program is the currently active program object and transform feedback mode is active.

void glLogicOp(GLenum opcode);
GL_INVALID_ENUM is generated if opcode is not an accepted value. 

void * glMapBuffer(GLenum target, GLenum access);
GL_INVALID_ENUM is generated if target is not one of the accepted targets. 
GL_INVALID_ENUM is generated if access is not GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE. 
GL_OUT_OF_MEMORY is generated when glMapBuffer is executed if the GL is unable to map the buffer object's data store. This may occur for a variety of system-specific reasons, such as the absence of sufficient remaining virtual memory. 
GL_INVALID_OPERATION is generated if the reserved buffer object name 0 is bound to target. 
GL_INVALID_OPERATION is generated if glMapBuffer is executed for a buffer object whose data store is already mapped. 
GL_INVALID_OPERATION is generated if glUnmapBuffer is executed for a buffer object whose data store is not currently mapped. 

GLboolean glUnmapBuffer(GLenum target);
GL_INVALID_ENUM is generated if target is not one of the accepted targets. 
GL_INVALID_ENUM is generated if access is not GL_READ_ONLY, GL_WRITE_ONLY, or GL_READ_WRITE. 
GL_OUT_OF_MEMORY is generated when glMapBuffer is executed if the GL is unable to map the buffer object's data store. This may occur for a variety of system-specific reasons, such as the absence of sufficient remaining virtual memory. 
GL_INVALID_OPERATION is generated if the reserved buffer object name 0 is bound to target. 
GL_INVALID_OPERATION is generated if glMapBuffer is executed for a buffer object whose data store is already mapped. 
GL_INVALID_OPERATION is generated if glUnmapBuffer is executed for a buffer object whose data store is not currently mapped. 

void *glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
GL_INVALID_VALUE is generated if either of offset or length is negative, or if offset + length is greater than the value of GL_BUFFER_SIZE. 
GL_INVALID_VALUE is generated if access has any bits set other than those defined above. 
GL_INVALID_OPERATION is generated for any of the following conditions: 
The buffer is already in a mapped state. 
Neither GL_MAP_READ_BIT or GL_MAP_WRITE_BIT is set. 
GL_MAP_READ_BIT is set and any of GL_MAP_INVALIDATE_RANGE_BIT, GL_MAP_INVALIDATE_BUFFER_BIT, or GL_MAP_UNSYNCHRONIZED_BIT is set. 
GL_MAP_FLUSH_EXPLICIT_BIT is set and GL_MAP_WRITE_BIT is not set. 
Any of GL_MAP_READ_BIT, GL_MAP_WRITE_BIT, GL_MAP_PERSISTENT_BIT, or GL_MAP_COHERENT_BIT are included in access, but the same bit is not included in the buffer's storage flags. 
GL_OUT_OF_MEMORY is generated if glMapBufferRange fails because memory for the mapping could not be obtained. 

void glMemoryBarrier(GLbitfield barriers);
GL_INVALID_VALUE is generated if barriers contains any unsupported bits, or is not the special value GL_ALL_BARRIER_BITS. 

void glMinSampleShading(GLfloat value);
None. 

void glMultiDrawArrays(GLenum mode, const GLint * first, const GLsizei * count, GLsizei drawcount);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if drawcount is negative. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array and the buffer object's data store is currently mapped. 

void glMultiDrawArraysIndirect(GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if stride is not a multiple of four. 
GL_INVALID_VALUE is generated if drawcount is negative. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or to the GL_DRAW_INDIRECT_BUFFER binding and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active. 

void glMultiDrawElements(GLenum mode, const GLsizei * count, GLenum type, const GLvoid * const * indices, GLsizei drawcount);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if drawcount is negative. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped. 

void glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei drawcount, const GLint *basevertex);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if drawcount is negative. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or the element array and the buffer object's data store is currently mapped. 

void glMultiDrawElementsIndirect(GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride);
GL_INVALID_ENUM is generated if mode is not an accepted value. 
GL_INVALID_VALUE is generated if stride is not a multiple of four. 
GL_INVALID_VALUE is generated if drawcount is negative. 
GL_INVALID_OPERATION is generated if no buffer is bound to the GL_ELEMENT_ARRAY_BUFFER binding, or if such a buffer's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to an enabled array or to the GL_DRAW_INDIRECT_BUFFER binding and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a geometry shader is active and mode is incompatible with the input primitive type of the geometry shader in the currently installed program object. 
GL_INVALID_OPERATION is generated if mode is GL_PATCHES and no tessellation control shader is active. 

void glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const char * label);
GL_INVALID_ENUM is generated if identifier is not one of the accepted object types. 
GL_INVALID_OPERATION is generated if name is not the name of an existing object of the type specified by identifier. 
GL_INVALID_VALUE is generated if the number of characters in label, excluding the null terminator when length is negative, is greater than the value of GL_MAX_LABEL_LENGTH. 

void glObjectPtrLabel(void * ptr, GLsizei length, const char * label);
GL_INVALID_VALUE is generated if ptr is not a valid sync object. 
GL_INVALID_VALUE is generated if the number of characters in label, excluding the null terminator when length is negative, is greater than the value of GL_MAX_LABEL_LENGTH. 

void glPatchParameteri(GLenum pname, GLint value);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated if pname is GL_PATCH_VERTICES and value is less than or equal to zero, or greater than the value of GL_MAX_PATCH_VERTICES. 

void glPatchParameterfv(GLenum pname, const GLfloat *values);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated if pname is GL_PATCH_VERTICES and value is less than or equal to zero, or greater than the value of GL_MAX_PATCH_VERTICES. 

void glPauseTransformFeedback(void);
GL_INVALID_OPERATION is generated if the currently bound transform feedback object is not active or is paused. 

void glPixelStoref(GLenum pname, GLfloat param);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated if a negative row length, pixel skip, or row skip value is specified, or if alignment is specified as other than 1, 2, 4, or 8. 

void glPixelStorei(GLenum pname, GLint param);
GL_INVALID_ENUM is generated if pname is not an accepted value. 
GL_INVALID_VALUE is generated if a negative row length, pixel skip, or row skip value is specified, or if alignment is specified as other than 1, 2, 4, or 8. 

void glPointParameterf(GLenum pname, GLfloat param);
GL_INVALID_VALUE is generated if the value specified for GL_POINT_FADE_THRESHOLD_SIZE is less than zero. 
GL_INVALID_ENUM is generated If the value specified for GL_POINT_SPRITE_COORD_ORIGIN is not GL_LOWER_LEFT or GL_UPPER_LEFT. 

void glPointParameteri(GLenum pname, GLint param);
GL_INVALID_VALUE is generated if the value specified for GL_POINT_FADE_THRESHOLD_SIZE is less than zero. 
GL_INVALID_ENUM is generated If the value specified for GL_POINT_SPRITE_COORD_ORIGIN is not GL_LOWER_LEFT or GL_UPPER_LEFT. 

void glPointParameterfv(GLenum pname, const GLfloat * params);
GL_INVALID_VALUE is generated if the value specified for GL_POINT_FADE_THRESHOLD_SIZE is less than zero. 
GL_INVALID_ENUM is generated If the value specified for GL_POINT_SPRITE_COORD_ORIGIN is not GL_LOWER_LEFT or GL_UPPER_LEFT. 

void glPointParameteriv(GLenum pname, const GLint * params);
GL_INVALID_VALUE is generated if the value specified for GL_POINT_FADE_THRESHOLD_SIZE is less than zero. 
GL_INVALID_ENUM is generated If the value specified for GL_POINT_SPRITE_COORD_ORIGIN is not GL_LOWER_LEFT or GL_UPPER_LEFT. 

void glPointSize(GLfloat size);
GL_INVALID_VALUE is generated if size is less than or equal to 0. 

void glPolygonMode(GLenum face, GLenum mode);
GL_INVALID_ENUM is generated if either face or mode is not an accepted value. 

void glPolygonOffset(GLfloat factor, GLfloat units);

void glPopDebugGroup(void);
GL_STACK_UNDERFLOW is generated if an attempt is made to pop the default debug group from the stack. 

void glPrimitiveRestartIndex(GLuint index);

void glProgramBinary(GLuint program, GLenum binaryFormat, const void *binary, GLsizei length);
GL_INVALID_OPERATION is generated if program is not the name of an existing program object. 
GL_INVALID_ENUM is generated if binaryFormat is not a value recognized by the implementation. 

void glProgramParameteri(GLuint program, GLenum pname, GLint value);
GL_INVALID_OPERATION is generated if program is not the name of an existing program object. 
GL_INVALID_ENUM is generated if pname is not one of the accepted values. 
GL_INVALID_VALUE is generated if value is not a valid value for the parameter named by pname. 

void glProgramUniform1f(GLuint program, GLint location, GLfloat v0);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform1i(GLuint program, GLint location, GLint v0);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform1ui(GLuint program, GLint location, GLuint v0);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform2ui(GLuint program, GLint location, GLint v0, GLuint v1);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform3ui(GLuint program, GLint location, GLint v0, GLint v1, GLuint v2);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform4ui(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLuint v3);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if program does not refer to a program object owned by the GL.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glProgramUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for program and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glProgramUniform1i and glProgramUniform1iv.

void glProvokingVertex(GLenum provokeMode);
GL_INVALID_ENUM is generated if provokeMode is not an accepted value. 

void glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const char * message);
GL_INVALID_ENUM is generated if the value of source is neither GL_DEBUG_SOURCE_APPLICATION nor GL_DEBUG_SOURCE_THIRD_PARTY. 
GL_INVALID_VALUE is generated if length is negative and the number of characters in message, excluding the null-terminator, is not less than the value of GL_MAX_DEBUG_MESSAGE_LENGTH. 

void glQueryCounter(GLuint id, GLenum target);
GL_INVALID_OPERATION is generated if id is the name of a query object that is already in use within a glBeginQuery / glEndQuery block. 
GL_INVALID_VALUE is generated if id is not the name of a query object returned from a previous call to glGenQueries. 
GL_INVALID_ENUM is generated if target is not GL_TIMESTAMP. 

void glReadBuffer(GLenum mode);
GL_INVALID_ENUM is generated if mode is not one of the twelve (or more) accepted values. 
GL_INVALID_OPERATION is generated if mode specifies a buffer that does not exist. 

void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid * data);
GL_INVALID_ENUM is generated if format or type is not an accepted value. 
GL_INVALID_VALUE is generated if either width or height is negative. 
GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and there is no stencil buffer. 
GL_INVALID_OPERATION is generated if format is GL_DEPTH_COMPONENT and there is no depth buffer. 
GL_INVALID_OPERATION is generated if format is GL_DEPTH_STENCIL and there is no depth buffer or if there is no stencil buffer. 
GL_INVALID_ENUM is generated if format is GL_DEPTH_STENCIL and type is not GL_UNSIGNED_INT_24_8 or GL_FLOAT_32_UNSIGNED_INT_24_8_REV. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and the data would be packed to the buffer object such that the memory writes required would exceed the data store size. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_PACK_BUFFER target and data is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type. 
GL_INVALID_OPERATION is generated if GL_READ_FRAMEBUFFER_BINDING is non-zero, the read framebuffer is complete, and the value of GL_SAMPLE_BUFFERS for the read framebuffer is greater than zero. 

void glReleaseShaderCompiler(void);

void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
GL_INVALID_ENUM is generated if target is not GL_RENDERBUFFER. 
GL_INVALID_VALUE is generated if either of width or height is negative, or greater than the value of GL_MAX_RENDERBUFFER_SIZE. 
GL_INVALID_ENUM is generated if internalformat is not a color-renderable, depth-renderable, or stencil-renderable format. 
GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store of the requested size. 

void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
GL_INVALID_ENUM is generated if target is not GL_RENDERBUFFER. 
GL_INVALID_VALUE is generated if samples is greater than GL_MAX_SAMPLES. 
GL_INVALID_ENUM is generated if internalformat is not a color-renderable, depth-renderable, or stencil-renderable format. 
GL_INVALID_OPERATION is generated if internalformat is a signed or unsigned integer format and samples is greater than the value of GL_MAX_INTEGER_SAMPLES 
GL_INVALID_VALUE is generated if either of width or height is negative, or greater than the value of GL_MAX_RENDERBUFFER_SIZE. 
GL_OUT_OF_MEMORY is generated if the GL is unable to create a data store of the requested size. 

void glResumeTransformFeedback(void);
GL_INVALID_OPERATION is generated if the currently bound transform feedback object is not active or is not paused. 

void glSampleCoverage(GLfloat value, GLboolean invert);

void glSampleMaski(GLuint maskNumber, GLbitfield mask);
GL_INVALID_VALUE is generated if maskIndex is greater than or equal to the value of GL_MAX_SAMPLE_MASK_WORDS. 

void glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param);
GL_INVALID_VALUE is generated if sampler is not the name of a sampler object previously returned from a call to glGenSamplers. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

void glSamplerParameteri(GLuint sampler, GLenum pname, GLint param);
GL_INVALID_VALUE is generated if sampler is not the name of a sampler object previously returned from a call to glGenSamplers. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

void glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat * params);
GL_INVALID_VALUE is generated if sampler is not the name of a sampler object previously returned from a call to glGenSamplers. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

void glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint * params);
GL_INVALID_VALUE is generated if sampler is not the name of a sampler object previously returned from a call to glGenSamplers. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

void glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint *params);
GL_INVALID_VALUE is generated if sampler is not the name of a sampler object previously returned from a call to glGenSamplers. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

void glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint *params);
GL_INVALID_VALUE is generated if sampler is not the name of a sampler object previously returned from a call to glGenSamplers. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

void glScissor(GLint x, GLint y, GLsizei width, GLsizei height);
GL_INVALID_VALUE is generated if either width or height is negative. 

void glScissorArrayv(GLuint first, GLsizei count, const GLint *v);
GL_INVALID_VALUE is generated if first is greater than or equal to the value of GL_MAX_VIEWPORTS. 
GL_INVALID_VALUE is generated if first + count is greater than or equal to the value of GL_MAX_VIEWPORTS. 
GL_INVALID_VALUE is generated if any width or height specified in the array v is negative. 

void glScissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_MAX_VIEWPORTS. 
GL_INVALID_VALUE is generated if any width or height specified in the array v is negative. 

void glScissorIndexedv(GLuint index, const GLint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_MAX_VIEWPORTS. 
GL_INVALID_VALUE is generated if any width or height specified in the array v is negative. 

void glShaderBinary(GLsizei count, const GLuint *shaders, GLenum binaryFormat, const void *binary, GLsizei length);
GL_INVALID_OPERATION is generated if more than one of the handles in shaders refers to the same shader object. 
GL_INVALID_ENUM is generated if binaryFormat is not an accepted value. 
GL_INVALID_VALUE is generated if the data pointed to by binary does not match the format specified by binaryFormat. 

void glShaderSource(GLuint shader, GLsizei count, const GLchar **string, const GLint *length);
GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if shader is not a shader object.
GL_INVALID_VALUE is generated if count is less than 0.

void glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
GL_INVALID_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS. 
GL_INVAILD_VALUE is generated if bindingindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIB_BINDINGS. 
GL_INVALID_OPERATION is generated if no vertex array object is bound. 

void glStencilFunc(GLenum func, GLint ref, GLuint mask);
GL_INVALID_ENUM is generated if func is not one of the eight accepted values. 

void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask);
GL_INVALID_ENUM is generated if func is not one of the eight accepted values. 

void glStencilMask(GLuint mask);

void glStencilMaskSeparate(GLenum face, GLuint mask);
GL_INVALID_ENUM is generated if face is not one of the accepted tokens. 

void glStencilOp(GLenum sfail, GLenum dpfail, GLenum dppass);
GL_INVALID_ENUM is generated if sfail, dpfail, or dppass is any value other than the defined constant values. 

void glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
GL_INVALID_ENUM is generated if face is any value other than GL_FRONT, GL_BACK, or GL_FRONT_AND_BACK. 
GL_INVALID_ENUM is generated if sfail, dpfail, or dppass is any value other than the eight defined constant values. 

void glTexBuffer(GLenum target, GLenum internalFormat, GLuint buffer);
GL_INVALID_ENUM is generated if target is not GL_TEXTURE_BUFFER. 
GL_INVALID_ENUM is generated if internalFormat is not one of the accepted tokens. 
GL_INVALID_OPERATION is generated if buffer is not zero or the name of an existing buffer object. 

void glTexBufferRange(GLenum target, GLenum internalFormat, GLuint buffer, GLintptr offset, GLsizeiptr size);
GL_INVALID_ENUM is generated if target is not GL_TEXTURE_BUFFER. 
GL_INVALID_VALUE is generated if offset is less than zero. 
GL_INVALID_VALUE is generated if size is less than or equal to zero. 
GL_INVALID_VALUE is generated if offset + size is greater than the value of GL_BUFFER_SIZE for buffer. 
GL_INVALID_VALUE is generated if offset is not an integer multiple of the value of GL_TEXTURE_BUFFER_OFFSET_ALIGNMENT. 

void glTexImage1D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid * data);
GL_INVALID_ENUM is generated if target is not GL_TEXTURE_1D or GL_PROXY_TEXTURE_1D. 
GL_INVALID_ENUM is generated if format is not an accepted format constant. Format constants other than GL_STENCIL_INDEX are accepted. 
GL_INVALID_ENUM is generated if type is not a type constant. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level is greater than log 2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if internalFormat is not one of the accepted resolution and format symbolic constants. 
GL_INVALID_VALUE is generated if width is less than 0 or greater than GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if border is not 0. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA. 
GL_INVALID_OPERATION is generated if format is GL_DEPTH_COMPONENT and internalFormat is not GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32. 
GL_INVALID_OPERATION is generated if internalFormat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32, and format is not GL_DEPTH_COMPONENT. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and data is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type. 

void glTexImage2D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * data);
GL_INVALID_ENUM is generated if target is not GL_TEXTURE_2D, GL_TEXTURE_1D_ARRAY, GL_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_2D, GL_PROXY_TEXTURE_1D_ARRAY, GL_PROXY_TEXTURE_RECTANGLE, GL_PROXY_TEXTURE_CUBE_MAP, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, or GL_TEXTURE_CUBE_MAP_NEGATIVE_Z. 
GL_INVALID_ENUM is generated if target is one of the six cube map 2D image targets and the width and height parameters are not equal. 
GL_INVALID_ENUM is generated if type is not a type constant. 
GL_INVALID_VALUE is generated if width is less than 0 or greater than GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if target is not GL_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_1D_ARRAY and height is less than 0 or greater than GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if target is GL_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_1D_ARRAY and height is less than 0 or greater than GL_MAX_ARRAY_TEXTURE_LAYERS. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level is greater than log 2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if internalFormat is not one of the accepted resolution and format symbolic constants. 
GL_INVALID_VALUE is generated if width or height is less than 0 or greater than GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if border is not 0. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_5_6_5_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV, and format is not GL_RGB. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_5_9_9_9_REV, and format is neither GL_RGBA nor GL_BGRA. 
GL_INVALID_OPERATION is generated if target is not GL_TEXTURE_2D, GL_PROXY_TEXTURE_2D, GL_TEXTURE_RECTANGLE, or GL_PROXY_TEXTURE_RECTANGLE, and internalFormat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32F. 
GL_INVALID_OPERATION is generated if format is GL_DEPTH_COMPONENT and internalFormat is not GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32F. 
GL_INVALID_OPERATION is generated if internalFormat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32F, and format is not GL_DEPTH_COMPONENT. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and data is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type. 
GL_INVALID_VALUE is generated if target is GL_TEXTURE_RECTANGLE or GL_PROXY_TEXTURE_RECTANGLE and level is not 0. 

void glTexImage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
GL_INVALID_OPERATION is generated if internalformat is a depth- or stencil-renderable format and samples is greater than the value of GL_MAX_DEPTH_TEXTURE_SAMPLES. 
GL_INVALID_OPERATION is generated if internalformat is a color-renderable format and samples is greater than the value of GL_MAX_COLOR_TEXTURE_SAMPLES. 
GL_INVALID_OPERATION is generated if internalformat is a signed or unsigned integer format and samples is greater than the value of GL_MAX_INTEGER_SAMPLES. 
GL_INVALID_VALUE is generated if either width or height negative or is greater than GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if samples is greater than GL_MAX_SAMPLES. 

void glTexImage3D(GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid * data);
GL_INVALID_ENUM is generated if target is not GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D. 
GL_INVALID_ENUM is generated if format is not an accepted format constant. Format constants other than GL_STENCIL_INDEX and GL_DEPTH_COMPONENT are accepted. 
GL_INVALID_ENUM is generated if type is not a type constant. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level is greater than log 2 ⁡ max , where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if internalFormat is not one of the accepted resolution and format symbolic constants. 
GL_INVALID_VALUE is generated if width, height, or depth is less than 0 or greater than GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if border is not 0. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA. 
GL_INVALID_OPERATION is generated if format or internalFormat is GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT24, or GL_DEPTH_COMPONENT32. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and data is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type. 

void glTexImage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
GL_INVALID_OPERATION is generated if internalformat is a depth- or stencil-renderable format and samples is greater than the value of GL_MAX_DEPTH_TEXTURE_SAMPLES. 
GL_INVALID_OPERATION is generated if internalformat is a color-renderable format and samples is greater than the value of GL_MAX_COLOR_TEXTURE_SAMPLES. 
GL_INVALID_OPERATION is generated if internalformat is a signed or unsigned integer format and samples is greater than the value of GL_MAX_INTEGER_SAMPLES. 
GL_INVALID_VALUE is generated if either width or height negative or is greater than GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if depth is negative or is greater than GL_MAX_ARRAY_TEXTURE_LAYERS. 
GL_INVALID_VALUE is generated if samples is greater than GL_MAX_SAMPLES. 

void glTexParameterf(GLenum target, GLenum pname, GLfloat param);
GL_INVALID_ENUM is generated if target or pname is not one of the accepted defined values. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

void glTexParameteri(GLenum target, GLenum pname, GLint param);
GL_INVALID_ENUM is generated if target or pname is not one of the accepted defined values. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

void glTexParameterfv(GLenum target, GLenum pname, const GLfloat * params);
GL_INVALID_ENUM is generated if target or pname is not one of the accepted defined values. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

void glTexParameteriv(GLenum target, GLenum pname, const GLint * params);
GL_INVALID_ENUM is generated if target or pname is not one of the accepted defined values. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

void glTexParameterIiv(GLenum target, GLenum pname, const GLint * params);
GL_INVALID_ENUM is generated if target or pname is not one of the accepted defined values. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

void glTexParameterIuiv(GLenum target, GLenum pname, const GLuint * params);
GL_INVALID_ENUM is generated if target or pname is not one of the accepted defined values. 
GL_INVALID_ENUM is generated if params should have a defined constant value (based on the value of pname) and does not. 

void glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
GL_INVALID_ENUM is generated if internalformat is not a valid sized internal format. 
GL_INVALID_ENUM is generated if target is not GL_TEXTURE_1D or GL_TEXTURE_2D. 
GL_INVALID_VALUE is generated if width or levels are less than 1. 
GL_INVALID_OPERATION is generated if levels is greater than log 2 width + 1 . 

void glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
GL_INVALID_ENUM is generated if internalformat is not a valid sized internal format. 
GL_INVALID_ENUM is generated if target is not one of the accepted target enumerants. 
GL_INVALID_VALUE is generated if width or levels are less than 1. 
GL_INVALID_OPERATION is generated if target is GL_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_1D_ARRAY and levels is greater than log 2 width + 1 . 
GL_INVALID_OPERATION is generated if target is not GL_TEXTURE_1D_ARRAY or GL_PROXY_TEXTURE_1D_ARRAY and levels is greater than log 2 max width , height + 1 . 

void glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
GL_INVALID_ENUM is generated if internalformat is not a valid color-renderable, depth-renderable or stencil-renderable format. 
GL_INVALID_ENUM is generated if target is not one of the accepted target enumerants. 
GL_INVALID_VALUE is generated if width or height are less than 1 or greater than the value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if samples is greater than the value of GL_MAX_SAMPLES. 
GL_INVALID_OPERATION is generated if the value of GL_TEXTURE_IMMUTABLE_FORMAT for the texture bound to target is not GL_FALSE. 

void glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
GL_INVALID_ENUM is generated if internalformat is not a valid sized internal format. 
GL_INVALID_ENUM is generated if target is not one of the accepted target enumerants. 
GL_INVALID_VALUE is generated if width or levels are less than 1. 
GL_INVALID_OPERATION is generated if target is GL_TEXTURE_3D or GL_PROXY_TEXTURE_3D and levels is greater than log 2 max width , height , depth + 1 . 
GL_INVALID_OPERATION is generated if target is GL_TEXTURE_2D_ARRAY, GL_PROXY_TEXTURE_2D_ARRAY, GL_TEXURE_CUBE_ARRAY, or GL_PROXY_TEXTURE_CUBE_MAP_ARRAY and levels is greater than log 2 max width , height + 1 . 

void glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
GL_INVALID_ENUM is generated if internalformat is not a valid color-renderable, depth-renderable or stencil-renderable format. 
GL_INVALID_ENUM is generated if target is not one of the accepted target enumerants. 
GL_INVALID_VALUE is generated if width or height are less than 1 or greater than the value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if depth is less than 1 or greater than the value of GL_MAX_ARRAY_TEXTURE_LAYERS. 
GL_INVALID_VALUE is generated if samples is greater than the value of GL_MAX_SAMPLES. 
GL_INVALID_OPERATION is generated if the value of GL_TEXTURE_IMMUTABLE_FORMAT for the texture bound to target is not GL_FALSE. 

void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid * data);
GL_INVALID_ENUM is generated if target is not one of the allowable values. 
GL_INVALID_ENUM is generated if format is not an accepted format constant. 
GL_INVALID_ENUM is generated if type is not a type constant. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level is greater than log 2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if xoffset < - b , or if xoffset + width > w - b , where w is the GL_TEXTURE_WIDTH, and b is the width of the GL_TEXTURE_BORDER of the texture image being modified. Note that w includes twice the border width. 
GL_INVALID_VALUE is generated if width is less than 0. 
GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage1D operation. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA. 
GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and data is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type. 

void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * data);
GL_INVALID_ENUM is generated if target is not GL_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_TEXTURE_1D_ARRAY. 
GL_INVALID_ENUM is generated if format is not an accepted format constant. 
GL_INVALID_ENUM is generated if type is not a type constant. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level is greater than log 2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if xoffset < - b , xoffset + width > w - b , yoffset < - b , or yoffset + height > h - b , where w is the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT, and b is the border width of the texture image being modified. Note that w and h include twice the border width. 
GL_INVALID_VALUE is generated if width or height is less than 0. 
GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage2D operation. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA. 
GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and data is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type. 

void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid * data);
GL_INVALID_ENUM is generated if /target is not GL_TEXTURE_3D or GL_TEXTURE_2D_ARRAY. 
GL_INVALID_ENUM is generated if format is not an accepted format constant. 
GL_INVALID_ENUM is generated if type is not a type constant. 
GL_INVALID_VALUE is generated if level is less than 0. 
GL_INVALID_VALUE may be generated if level is greater than log 2 max, where max is the returned value of GL_MAX_TEXTURE_SIZE. 
GL_INVALID_VALUE is generated if xoffset < - b , xoffset + width > w - b , yoffset < - b , or yoffset + height > h - b , or zoffset < - b , or zoffset + depth > d - b , where w is the GL_TEXTURE_WIDTH, h is the GL_TEXTURE_HEIGHT, d is the GL_TEXTURE_DEPTH and b is the border width of the texture image being modified. Note that w, h, and d include twice the border width. 
GL_INVALID_VALUE is generated if width, height, or depth is less than 0. 
GL_INVALID_OPERATION is generated if the texture array has not been defined by a previous glTexImage3D or glTexStorage3D operation. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_BYTE_3_3_2, GL_UNSIGNED_BYTE_2_3_3_REV, GL_UNSIGNED_SHORT_5_6_5, or GL_UNSIGNED_SHORT_5_6_5_REV and format is not GL_RGB. 
GL_INVALID_OPERATION is generated if type is one of GL_UNSIGNED_SHORT_4_4_4_4, GL_UNSIGNED_SHORT_4_4_4_4_REV, GL_UNSIGNED_SHORT_5_5_5_1, GL_UNSIGNED_SHORT_1_5_5_5_REV, GL_UNSIGNED_INT_8_8_8_8, GL_UNSIGNED_INT_8_8_8_8_REV, GL_UNSIGNED_INT_10_10_10_2, or GL_UNSIGNED_INT_2_10_10_10_REV and format is neither GL_RGBA nor GL_BGRA. 
GL_INVALID_OPERATION is generated if format is GL_STENCIL_INDEX and the base internal format is not GL_STENCIL_INDEX. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the buffer object's data store is currently mapped. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and the data would be unpacked from the buffer object such that the memory reads required would exceed the data store size. 
GL_INVALID_OPERATION is generated if a non-zero buffer object name is bound to the GL_PIXEL_UNPACK_BUFFER target and data is not evenly divisible into the number of bytes needed to store in memory a datum indicated by type. 

void glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
GL_INVALID_VALUE is generated if minlayer or minlevel are larger than the greatest layer or level of origtexture. 
GL_INVALID_OPERATION is generated if target is not compatible with the target of origtexture. 
GL_INVALID_OPERATION is generated if the dimensions of origtexture are greater than the maximum supported dimensions for target. 
GL_INVALID_OPERATION is generated if internalformat is not compatible with the internal format of origtexture. 
GL_INVALID_OPERATION is generated if texture has already been bound or otherwise given a target. 
GL_INVALID_OPERATION is generated if the value of GL_TEXTURE_IMMUTABLE_FORMAT for origtexture is not GL_TRUE. 
GL_INVALID_OPERATION is generated if origtexture is not the name of an existing texture object. 
GL_INVALID_VALUE is generaged if target is GL_TEXTURE_CUBE_MAP and numlayers is not 6, or if target is GL_TEXTURE_CUBE_MAP_ARRAY and numlayers is not an integer multiple of 6. 
GL_INVALID_VALUE is generated if target is GL_TEXTURE_1D, GL_TEXTURE_2D, GL_TEXTURE_3D, GL_TEXTURE_RECTANGLE, or GL_TEXTURE_2D_MULTISAMPLE and numlayers does not equal 1. 
GL_INVALID_VALUE is generated if texture zero or is not the name of a texture previously returned from a successful call to glGenTextures. 

void glTransformFeedbackVaryings(GLuintprogram, GLsizeicount, const char **varyings, GLenumbufferMode);
GL_INVALID_VALUE is generated if program is not the name of a program object. 
GL_INVALID_VALUE is generated if bufferMode is GL_SEPARATE_ATTRIBS and count is greater than the implementation-dependent limit GL_MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS. 

void glUniform1f(GLint location, GLfloat v0);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform2f(GLint location, GLfloat v0, GLfloat v1);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform1i(GLint location, GLint v0);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform2i(GLint location, GLint v0, GLint v1);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform1ui(GLint location, GLuint v0);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform2ui(GLint location, GLuint v0, GLuint v1);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform1fv(GLint location, GLsizei count, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform2fv(GLint location, GLsizei count, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform3fv(GLint location, GLsizei count, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform4fv(GLint location, GLsizei count, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform1iv(GLint location, GLsizei count, const GLint *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform2iv(GLint location, GLsizei count, const GLint *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform3iv(GLint location, GLsizei count, const GLint *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform4iv(GLint location, GLsizei count, const GLint *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform1uiv(GLint location, GLsizei count, const GLuint *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform2uiv(GLint location, GLsizei count, const GLuint *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform3uiv(GLint location, GLsizei count, const GLuint *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniform4uiv(GLint location, GLsizei count, const GLuint *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
GL_INVALID_OPERATION is generated if there is no current program object.
GL_INVALID_OPERATION is generated if the size of the uniform variable declared in the shader does not match the size indicated by the glUniform command.
GL_INVALID_OPERATION is generated if one of the signed or unsigned integer variants of this function is used to load a uniform variable of type float, vec2, vec3, vec4, or an array of these, or if one of the floating-point variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the signed integer variants of this function is used to load a uniform variable of type unsigned int, uvec2, uvec3, uvec4, or an array of these.
GL_INVALID_OPERATION is generated if one of the unsigned integer variants of this function is used to load a uniform variable of type int, ivec2, ivec3, ivec4, or an array of these.
GL_INVALID_OPERATION is generated if location is an invalid uniform location for the current program object and location is not equal to -1.
GL_INVALID_VALUE is generated if count is less than 0.
GL_INVALID_OPERATION is generated if count is greater than 1 and the indicated uniform variable is not an array variable.
GL_INVALID_OPERATION is generated if a sampler is loaded using a command other than glUniform1i and glUniform1iv.

void glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
GL_INVALID_VALUE is generated if uniformBlockIndex is not an active uniform block index of program. 
GL_INVALID_VALUE is generated if uniformBlockBinding is greater than or equal to the value of GL_MAX_UNIFORM_BUFFER_BINDINGS. 
GL_INVALID_VALUE is generated if program is not the name of a program object generated by the GL. 

void glUniformSubroutinesuiv(GLenum shadertype, GLsizei count, const GLuint *indices);
GL_INVALID_OPERATION is generated if no program object is current. 
GL_INVALID_VALUE is generated if count is not equal to the value of GL_ACTIVE_SUBROUTINE_UNIFORM_LOCATIONS for the shader stage shadertype of the current program. 
GL_INVALID_VALUE is generated if any value in indices is geater than or equal to the value of GL_ACTIVE_SUBROUTINES for the shader stage shadertype of the current program. 
GL_INVALID_ENUM is generated if shadertype is not one of the accepted values. 

void glUseProgram(GLuint program);
GL_INVALID_VALUE is generated if program is neither 0 nor a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.
GL_INVALID_OPERATION is generated if program could not be made part of current state.
GL_INVALID_OPERATION is generated if transform feedback mode is active.

void glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program);
GL_INVALID_VALUE is generated if shaders contains set bits that are not recognized, and is not the reserved value GL_ALL_SHADER_BITS. 
GL_INVALID_OPERATION is generated if program refers to a program object that was not linked with its GL_PROGRAM_SEPARABLE status set. 
GL_INVALID_OPERATION is generated if program refers to a program object that has not been successfully linked. 
GL_INVALID_OPERATION is generated if pipeline is not a name previously returned from a call to glGenProgramPipelines or if such a name has been deleted by a call to glDeleteProgramPipelines. 

void glValidateProgram(GLuint program);
GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.
GL_INVALID_OPERATION is generated if program is not a program object.

void glValidateProgramPipeline(GLuint pipeline);
GL_INVALID_OPERATION is generated if pipeline is not a name previously returned from a call to glGenProgramPipelines or if such a name has been deleted by a call to glDeleteProgramPipelines. 

void glVertexAttrib1f(GLuint index, GLfloat v0);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib1s(GLuint index, GLshort v0);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib1d(GLuint index, GLdouble v0);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribI1i(GLuint index, GLint v0);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribI1ui(GLuint index, GLuint v0);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib2f(GLuint index, GLfloat v0, GLfloat v1);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib2s(GLuint index, GLshort v0, GLshort v1);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib2d(GLuint index, GLdouble v0, GLdouble v1);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribI2i(GLuint index, GLint v0, GLint v1);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribI2ui(GLuint index, GLuint v0, GLuint v1);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib3f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib3s(GLuint index, GLshort v0, GLshort v1, GLshort v2);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribI3i(GLuint index, GLint v0, GLint v1, GLint v2);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribI3ui(GLuint index, GLuint v0, GLuint v1, GLuint v2);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib4f(GLuint index, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib4s(GLuint index, GLshort v0, GLshort v1, GLshort v2, GLshort v3);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib4Nub(GLuint index, GLubyte v0, GLubyte v1, GLubyte v2, GLubyte v3);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribI4i(GLuint index, GLint v0, GLint v1, GLint v2, GLint v3);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribI4ui(GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribL1d(GLuint index, GLdouble v0);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribL2d(GLuint index, GLdouble v0, GLdouble v1);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribL3d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribL4d(GLuint index, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib1fv(GLuint index, const GLfloat *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib1sv(GLuint index, const GLshort *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib1dv(GLuint index, const GLdouble *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribI1iv(GLuint index, const GLint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribI1uiv(GLuint index, const GLuint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib2fv(GLuint index, const GLfloat *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib2sv(GLuint index, const GLshort *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib2dv(GLuint index, const GLdouble *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribI2iv(GLuint index, const GLint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribI2uiv(GLuint index, const GLuint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib3fv(GLuint index, const GLfloat *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib3sv(GLuint index, const GLshort *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib3dv(GLuint index, const GLdouble *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribI3iv(GLuint index, const GLint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribI3uiv(GLuint index, const GLuint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib4fv(GLuint index, const GLfloat *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib4sv(GLuint index, const GLshort *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib4dv(GLuint index, const GLdouble *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib4iv(GLuint index, const GLint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib4bv(GLuint index, const GLbyte *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib4ubv(GLuint index, const GLubyte *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib4usv(GLuint index, const GLushort *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib4uiv(GLuint index, const GLuint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib4Nbv(GLuint index, const GLbyte *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib4Nsv(GLuint index, const GLshort *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib4Niv(GLuint index, const GLint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib4Nubv(GLuint index, const GLubyte *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib4Nusv(GLuint index, const GLushort *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttrib4Nuiv(GLuint index, const GLuint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribI4bv(GLuint index, const GLbyte *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribI4ubv(GLuint index, const GLubyte *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribI4sv(GLuint index, const GLshort *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribI4usv(GLuint index, const GLushort *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribI4iv(GLuint index, const GLint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribI4uiv(GLuint index, const GLuint *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribL1dv(GLuint index, const GLdouble *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribL2dv(GLuint index, const GLdouble *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribL3dv(GLuint index, const GLdouble *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribL4dv(GLuint index, const GLdouble *v);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_ENUM is generated if glVertexAttribP* is used with a type other than GL_INT_2_10_10_10_REV, GL_UNSIGNED_INT_2_10_10_10_REV, or GL_UNSIGNED_INT_10F_11F_11F_REV.
GL_INVALID_ENUM is generated if glVertexAttribL is used with a type other than GL_DOUBLE.

void glVertexAttribBinding(GLuint attribindex, GLuint bindingindex);
GL_INVALID_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS. 
GL_INVAILD_VALUE is generated if bindingindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIB_BINDINGS. 
GL_INVALID_OPERATION is generated if no vertex array object is bound. 

void glVertexAttribDivisor(GLuint index, GLuint divisor);
GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS. 

void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
GL_INVAILD_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS. 
GL_INVALID_VALUE is generated if size is not one of the accepted values. 
GL_INVALID_VALUE is generated if relativeoffset is greater than the value of GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET. 
GL_INVALID_ENUM is generated if type is not one of the accepted tokens. 
GL_INVALID_OPERATION is generated if no vertex array object is bound. 

void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
GL_INVAILD_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS. 
GL_INVALID_VALUE is generated if size is not one of the accepted values. 
GL_INVALID_VALUE is generated if relativeoffset is greater than the value of GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET. 
GL_INVALID_ENUM is generated if type is not one of the accepted tokens. 
GL_INVALID_OPERATION is generated if no vertex array object is bound. 

void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
GL_INVAILD_VALUE is generated if attribindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIBS. 
GL_INVALID_VALUE is generated if size is not one of the accepted values. 
GL_INVALID_VALUE is generated if relativeoffset is greater than the value of GL_MAX_VERTEX_ATTRIB_RELATIVE_OFFSET. 
GL_INVALID_ENUM is generated if type is not one of the accepted tokens. 
GL_INVALID_OPERATION is generated if no vertex array object is bound. 

void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_VALUE is generated if size is not 1, 2, 3, 4 or (for glVertexAttribPointer), GL_BGRA.
GL_INVALID_ENUM is generated if type is not an accepted value.
GL_INVALID_VALUE is generated if stride is negative.
GL_INVALID_OPERATION is generated if size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
GL_INVALID_OPERATION is generated if type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV and size is not 4 or GL_BGRA.
GL_INVALID_OPERATION is generated if type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
GL_INVALID_OPERATION is generated by glVertexAttribPointer if size is GL_BGRA and noramlized is GL_FALSE.
GL_INVALID_OPERATION is generated if zero is bound to the GL_ARRAY_BUFFER buffer object binding point and the pointer argument is not NULL.

void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_VALUE is generated if size is not 1, 2, 3, 4 or (for glVertexAttribPointer), GL_BGRA.
GL_INVALID_ENUM is generated if type is not an accepted value.
GL_INVALID_VALUE is generated if stride is negative.
GL_INVALID_OPERATION is generated if size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
GL_INVALID_OPERATION is generated if type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV and size is not 4 or GL_BGRA.
GL_INVALID_OPERATION is generated if type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
GL_INVALID_OPERATION is generated by glVertexAttribPointer if size is GL_BGRA and noramlized is GL_FALSE.
GL_INVALID_OPERATION is generated if zero is bound to the GL_ARRAY_BUFFER buffer object binding point and the pointer argument is not NULL.

void glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid * pointer);
GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.
GL_INVALID_VALUE is generated if size is not 1, 2, 3, 4 or (for glVertexAttribPointer), GL_BGRA.
GL_INVALID_ENUM is generated if type is not an accepted value.
GL_INVALID_VALUE is generated if stride is negative.
GL_INVALID_OPERATION is generated if size is GL_BGRA and type is not GL_UNSIGNED_BYTE, GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV.
GL_INVALID_OPERATION is generated if type is GL_INT_2_10_10_10_REV or GL_UNSIGNED_INT_2_10_10_10_REV and size is not 4 or GL_BGRA.
GL_INVALID_OPERATION is generated if type is GL_UNSIGNED_INT_10F_11F_11F_REV and size is not 3.
GL_INVALID_OPERATION is generated by glVertexAttribPointer if size is GL_BGRA and noramlized is GL_FALSE.
GL_INVALID_OPERATION is generated if zero is bound to the GL_ARRAY_BUFFER buffer object binding point and the pointer argument is not NULL.

void glVertexBindingDivisor(GLuint bindingindex, GLuint divisor);
GL_INVAILD_VALUE is generated if bindingindex is greater than or equal to the value of GL_MAX_VERTEX_ATTRIB_BINDINGS. 
GL_INVALID_OPERATION is generated if no vertex array object is bound. 

void glViewport(GLint x, GLint y, GLsizei width, GLsizei height);
GL_INVALID_VALUE is generated if either width or height is negative. 

void glViewportArrayv(GLuint first, GLsizei count, const GLfloat *v);
GL_INVALID_VALUE is generated if first is greater than or equal to the value of GL_MAX_VIEWPORTS. 
GL_INVALID_VALUE is generated if first + count is greater than or equal to the value of GL_MAX_VIEWPORTS. 
GL_INVALID_VALUE is generated if either width or height is negative. 

void glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_MAX_VIEWPORTS. 
GL_INVALID_VALUE is generated if either width or height is negative. 

void glViewportIndexedfv(GLuint index, const GLfloat *v);
GL_INVALID_VALUE is generated if index is greater than or equal to the value of GL_MAX_VIEWPORTS. 
GL_INVALID_VALUE is generated if either width or height is negative. 

void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout);
GL_INVALID_VALUE is generated if sync is not the name of a sync object. 
GL_INVALID_VALUE is generated if flags is not zero. 
GL_INVALID_VALUE is generated if timeout is not GL_TIMEOUT_IGNORED. 

